# -*- coding: utf-8 -*-
"""PyNoteK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q6jMi9SNb0RJtJQ_bZe3z6c1d24polwu

### 1.Introduction

####1-1. Python Libraries

Pandas: used for data analysis

Numpy: multidimensional arrays

TensorFlow: ML approaches

Matplotlib, Seaborn, Bokeh: data visualization

Keras: high-level neural network API

Scikit-learn: ML algorithms

SciPy: algorithms to use with Numpy

SQLAlchemy: Python SQL Toolkit

Theano: Deep Neural Networks

SymPy: Symbolic math

AirFlow, Dask, Luigi: data engineering tool

PyBrain: ML algorithms

Pattern: natural language processing

####1-2. Colab Shortcuts

Execute : Shift + Enter

Select : Shift + Up / Down

Add Code Cell Above : Ctrl + M A (Esc + A)

Add Code Cell Below : Ctrl + M B (Esc + B)

To Text (Markdown) : Ctrl + M M

To Code : Ctrl + M Y

Delete : Ctrl + M D  

Undo : Ctrl + M Z

####1-3. Colab Python Examples
"""

!python --version

print("Hello World!") #shift + enter to execute

1 + 2

help()

"""### 2.Variables

####2-1. Variable Name

*   can be arbitrarily long.
*   can contain both letters and numbers.
*   should begin with a letter.
*   can begin with underscore _.
*   can be written in lowercase and uppercase letter.
*   can not be a Python Keyword:

*Python Keyword:
and, del, from, not, while, as, elif, global, or, with, assert, else, if, pass, yield, break, except, import, print, class, in, raise, continue, finally, is, return, def, for, lambda, try.
"""

_var = 1
_var

"""####2-2. Basic Built-in Function

* type(object) : returns the type of the given object
"""

type(_var)

type(5.7)

type(False)

type('D')

"""* int(object) : Return an integer object constructed from a number or string x
* float(object) : Return a floating-point object constructed from a number or string x
* bool(object) : Return a boolean value, True or False
* str(object) : Return a string object
"""

int(1.9)

float(1)

bool(1 == 2)

str(5)

"""####2-3. String Print Format Basics

1) printf style using %
* %[flags][width][.precision]type
* "%_" : Use "substitution type_” for value conversion.
* subsitution type: 'd' int, 'f' float, 's' str, 'o' oct, 'x' hex.
* "%#_" : Show base.
"""

print("%x" %15)

"%X" %15

"%#x" %15

"""2) str.format() function"""

a = 2
b = 3
s = "{0} x {2} != {1}".format(a, b, a * b)
print(s)

s = "{:0.5f}".format(3.2 + 2.1)
print(s) #format the number with zero padding and 5 decimal places in fractional part

type(s)

"""3) f-string"""

n = "apple"
x = 5
s = f"There are {x} {n}s."
print(s)

"""####2-4. Number Data Type and Base

1) Decimal
"""

x = 10 #integer
type(x)

y = 10.79 #floating-point
type(y)

"""* int("string", base=number) : Convert string with Explicit base to Decimal number"""

int("111", base=2) #convert binary string to decimal

int("F", base=16) #convert hexadecimal string to decimal

"""2) Binary

* bin(object) : convert an integer number to a binary string prefixed with “0b”
"""

bin(4)

"""3) Octal

* oct(object) : convert an integer number to an octal string prefixed with “0o”
"""

oct(8)

"""4) Hexadecimal

* hex(object) : convert an integer number to a lowercase hexadecimal string prefixed with “0x”
"""

hex(15)

"""### 3.Operators

####3-1. Expressions and Statements

1) Expression : A combination of values, variables, and operators. (식 = 값으로 평가되는 모든 문장)
"""

"Hello" #literal expression
x = 10 #operator expression
x #identifier expression

"""2) Statement : A unit of code that the interpreter can execute. (문 = 최소 실행 단위)"""

#int x #declaration statement
x = 10 #assignment statement
if (x == 10): #conditional statement
  a = 1
while (a < 3): #iteration statement
  print(a)
  a += 1

"""####3-2. Arithmetic Operator"""

x = 1
y = 2
print(x + y) #Addition: adds two operands
print(x - y) #Subtraction: subtracts two operands
print(x * y) #Multiplication: multiplies two operands
print(x / y) #Division (float): divides the first operand by the second
x = 3
print(x // y) #Division (floor): divides the first operand by the second
x = 2
print(x % y)  #Modulus: returns the remainder when the first operand is divided by the second
print(x ** y) #Power (Exponent): Returns first raised to power second

print(abs(-2)) #Built-in Function: Return the absolute value of a number
print(int(3.9))
print(float(3))

"""* Order of Operations (PEMDAS):
 1. parentheses ()
 2. exponents **
 3. multiplication *
 4. division /
 5. addition +
 6. subtraction -
"""

print(10 - 5 / 5)
print(1 + 2 * 3 ** 2 / 3)
print((10 - 5) / 5)

"""####3-3. Bitwise Operator

1) Bitwise Operator: is used to perform bitwise calculations on integers.

The integers are first converted into binary, and then operations are performed bitwise.
"""

a = 0b10
b = 0b01
a | b

"""* x << y : Binary Left Shift
* x >> y : Binary Right Shift
* x & y : Binary AND
* x | y : Binary OR
* x ^ y : Binary XOR (Exclusive OR)
* ~ x : Binary NOT (Complement)
"""

print(4 << 5) #4 * 2^5
print(48 >> 2) #48 / 2

print(bin(48))
print(int(0b1100)) #48 >> 2

format(212, '#b') #format() method: returns a formatted value based on the specified formatter.

'{:b}'.format(212) #format(212, 'b') : format the integer to binary

b = 0b110 & 0b011 #Conjunction: true if both p and q are true, false otherwise
bin(b)

a = 0b100 | 0b011 #Disjunction: false if both p and q are false, true otherwise
bin(a)

c = 0b100 ^ 0b001 #Exclusive Disjunction: true if only exactly one of its both inputs is true
bin(c)

print(not(0)) #Negation: Unary operator

"""2) User-defined function: 'def' keyword is used to declare user-defined functions"""

#def function_name(argument1, argument2, ...):
#    statements...    →  Conditional and Loop Statements, Expression Statement (Return etc.)

def negation(p):
  return not p

print("p not a")
for p in [True, False]:
  a = negation(p)
  print(p, a, sep=' ~ ')

def conjunct(p, q):
  return p and q

print("p and q")
for p in [True, False]:
  for q in [True, False]: #nested loop
    a = conjunct(p, q)
    print(p, '&', q, '=', a)

def disjunct(p, q):
  return p or q

print("p or q")
for p in [True, False]:
  for q in [True, False]:
    a = disjunct(p, q)
    print(p, '|', q, '=', a)

def exclusive_disjunct(p, q):
  return (p and not q) or (not p and q)

print("p xor q")
for p in [True, False]:
  for q in [True, False]:
    a = exclusive_disjunct(p, q)
    print(p, '^', q, '=', a)

for p in [True, False]:
  for q in [True, False]:
    a = conjunct(p, q)
    b = negation(p)
    print ("{:<3} {:<4} {:<5} {:<3}".format(p, q, a, b)) #format() :left align<reserved spaces

"""####3-4. Operator Precedence

from highest precedence (most binding) to lowest:
1. (expression) : parenthesized expression
2. x[index], x[index:index], x(arguments...), x.attribute : array subscription, slicing, call, attribute reference
3. ** : exponentiation
4. +x, -x, ~x : unary positive, negative sign, bitwise NOT
5. *, @, /, //, % : multiplication, matrix multiplication, division, floor division, remainder
6. +, - : addition and subtraction
7. <<, >> : bitwise left and right shifts
8. & : bitwise AND
9. ^ : bitwise XOR
10. | : bitwise OR
11. in, not in, is, is not : membership tests and identity tests
12. !=, == : equality operator
13. <, <=, >, >= : comparison operator
14. not x : boolean NOT
15. and : boolean AND
16. or : boolean OR
17. if ~ else : conditional expression
18. lambda : Lambda expression
19. := : assignment expression

1) Assignment Expression
"""

#walrus operator :=
print(n := 5) #accomplish two tasks at once
#print(n = 5) : 'n' is an invalid keyword argument for print()

while (val := input("Enter an number:")) != '': #if there is no input(no value assigned to val), while loop ends
  print("Done!")

"""2) Lambda Function

lambda parameter(s) : expression
"""

#lambda is a keyword in Python for defining the anonymous function (a function without a name)
y = lambda x : x // 2
print(y(13))

(lambda x , y : x + y)(10, 20)

"""3) Assignment Operator

a += b  a -= b  a *= b  a /= b
    a %= b  a //= b a **= b
    a &= b  a |= b	a^= b
    a <<= b	a >>= b
"""

x = 3
x += 5
x

"""####3-5. String Operator

1) String Concatenation
"""

fir = 'Sejong'
sec = 'University'
print(fir + " " + sec)

print('A' * 2)

"""2) Comment

* #: Single-line comments (ctrl + /)
* ''' ''': Multi-line comments
* ''' ''': Docstring for commenting on modules, methods, functions, objects, and classes
"""

# single line comments
"""
multi
line
comments
"""
def square(n):
  '''Takes in a number n, returns the square of n'''
  return n ** 2
square(7)

"""3) User Input"""

a = input("Please enter a number:")
type(a)

x = int(input("Please enter a number: "))
print(x)
type(x)

"""4) Standard Output"""

print("A is", 65)

print(1, 2, 3, 4, sep='&')

print("Hello", end='?')
print("Bye", end='!')

"""### 4.Data Types

####4-1. String

1) String Print Format
"""

print('He said "Hello".')
print("She said \"Hello\".")

a = '1' #if int type : TypeError
b = '2'
c = "Hello"
print(a + b + c)

n = "Kim"
print("Hello %s" %n)

print("I ate %d %ss." %(5, "apple"))
print("%c is right." %'A')

"{0:!<7}".format("Hi")

"""2) String Built-in Function"""

s = "sejong"
#s[0] = 'H'  #TypeError: 'str' object does not support item assignment (immutable)
s2 = 'h' + s[1:]
s2

s = "python"
type(s)

s = 'I like it.'
len(s)

s = "hello"
l = len(s)

print(s[l - 1] == s[-1]) #points to the same last element

s = "life is great"
print(s.count('e'))

print(s.index('e')) #first same letter

print(s.find('e'))
print(s.find('e', 4))     #find starts from number
print(s.find('e', 4, 7))  #and steps from second number

s = "goodnight"
print(s.capitalize())
print(s.upper()) #.lower()
print(s)

",".join("ABCD")

" ABCDE ".lstrip() #.rstrip() #.strip()

s = "This is left."
s.replace("left", "right")

s = "I think it is there."
s.split() #split a string to a list

s = "A:B:C:D"
s.split(':')

"""3) String User-defined Function"""

prefix = "JKLMNOPQ"
suffix = 'ack'

for letter in prefix:     #making a word
  if letter == 'O' or letter == 'Q':
    print(letter + 'u' + suffix)
  else:
    print(letter + suffix)

def in_backwards(string):
  backwards_len = -len(string) #negative value of len
  index = -1
  while index >= backwards_len:
    print(string[index])       #starts from last element
    index -= 1

in_backwards("sejong")

def is_palindrome(s):
  return s == s[::-1]   #step starts from last char == extracts backward string

is_palindrome('madam')

def find_index(word, letter):
  i = 0
  while i < len(word):
    if word[i] == letter:
      return i            #returns index value
    i += 1
  return -1

find_index('sejong', 'j')

def find_letter(word, letter, i):
  while i < len(word):
    #if found the letter, stops iteration and returns index
    if word[i] == letter:
      return i
    i += 1
  return -1

def count_letter(word, letter):
  count = 0
  i = find_letter(word, letter, 0)
  #if letter exists, from the first same letter
  while i != -1:
    count += 1
    i = find_letter(word, letter, i + 1)
  print(count)

count_letter('sejong university', 'i')

def is_reverse(word1, word2):
  if len(word1) != len(word2):
    return False
  i = 0
  j = len(word2) - 1
  while j >= 0:
    #comparing starts from first and last element
    if word1[i] != word2[j]:
      return False
    i += 1
    j -= 1
  return True

is_reverse('sejong', 'gnojes')

def any_lowercase(st):
  for ch in st:
    if ch.islower():
      return True
    else: #if there is upper char, stops iteration and returns false
      return False

any_lowercase('sejong')

for i in range(26):
  print(chr(ord('a') + i), i + 1, end=', ') #increase to next char, index starts from 1

def wrap_around(c, lower_limit, upper_limit, i):
  #limits the offset value
  i %= 26
  new_c = ord(c) + i        #returns char ordinal position + offset i
  #makes new char does not go out of bound
  if new_c > upper_limit:
    new_c -= 26
  elif new_c < lower_limit:
    new_c += 26
  return chr(new_c)         #returns ascii char of that value

def rotate_word(s, i):
  new_s = ""
  for c in s:
    if 65 <= ord(c) <= 90:    #uppercase
      new_c = wrap_around(c, 65, 90, i)
    elif 97 <= ord(c) <= 122: #lowercase
      new_c = wrap_around(c, 97, 122, i)
    else:
      print("enter an alphabetic character")
      return
    #make a string with rotated words
    new_s += new_c
  return new_s

print(rotate_word('Sejong', 6))
print(rotate_word('Sejong', 32))

"""####4-2. List

1) List Index and Basic Operation
"""

s = [1, 2, 3, 4]
print(s[0])
print(s[-1]) #first element from the last

s = [1, 2, 3, [4, 5, 6], "University"] #fifth element is considered as an array
print(s[3])
print(s[3][0])
print(s[4][0])

s[0] = 99
print(s)

a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
c

a * 3

"""2) List Slicing"""

a = [1, 2, 3, 4, 5, 6, 7, 8]
print(a[0:5])
print(a)        #slicing itself does not alter the original array

b = [1, 2, 2, 2, 5]
b[2:4] = [3, 4] #use slicing to change several elements at once
print(b)

ori = [1, 2, 3, 4, 5, 6, 7, 8]
new = ori
new[2] = "Three"

print(new is ori)
print(ori)  #original list has also changed
print(new)

ori = [1, 2, 3, 4, 5, 6, 7, 8]
new = ori[:]
new[2] = "Three"

print(new is ori)
print(ori)  #original list remains unchanged
print(new)

a[:] #all

a[:5] #~not include a[5]

a[1:] #include a[1]~

a[:-1] #~not include last one

a[-3:] #include 6~

a[2:-1] #include a[2]~ #~not include last one

a[-3:-1] #include 6~ #~not include last one

a[::2]  #stride of a slice [start:end:stride]

a[::-1] #reverse print array using stride

a[-2:2:-2] #include 7~ #~not include a[2] #reverse stride

"""3) List Built-in Function"""

st = "Sejong"
list(st)

s = list()
print(s)

s.append(1)
print(s)
print(len(s))

s.insert(1, 2) #s[1] = 2
s

s.extend([3, 4, 5])
s

s = [1, 2, 3, 4, 5, 6]
s.remove(2)
s

s = [1, 2, 3, 4, 5, 6]
del s[1]
print(s)

s = [1, 2, 3, 4, 5, 6]
del s[2:] #include s[2]~ delete
print(s)

s = [1, 2, 3, 4, 5, 6]
print(s.pop()) #pop out last element (stack)
print(s)

s = [1, 2, 3, 4, 5, 6]
s.clear()
s

s = [1, 3, 4, 6, 5, 2]
s.sort()
s

s = [1, 3, 4, 6, 5, 2]
s.reverse() #does not sort, just reverse
s

s = [1, 3, 6, 9, 3, 7, 10]
s.count(3)

s.index(3) #return first index of given value

"""4) List with Membership and Identity Operator"""

12 in [1, 2, 3] #to check if an element exists in a sequence or not

12 not in [1, 2, 3]

x = [1, 2, 3] #True if the variables on either side of the operator point to the same object (the same space in memory) and false otherwise
y = x
print(x is y)
print(id(x))
print(id(y))

x = [1, 2, 3]
z = [1, 2, 3]
print(x is z)
print(id(x))
print(id(z))
print(x is not z)
print(x == z)

#s = [1, 3, 2, 9.14, 7]
#AssertionError: oops! not int included!

s = [1, 3, 2, 9, 7]
def test(i):
    assert type(i) is int, 'oops! not int included!'

for i in s:
    test(i)

"""####4-3. Tuple"""

t = 0,
type(t)

tuple([1, 2, 3])

t1 = (1, 2, 3)
t2 = 1, 2, 3
print(t1)
print(t2)

t3 = t1 + t2
t4 = t1 * 3
print(t3)
print(t4)

len(t1)

t1[1:]

#t1[0] = 4 -> TypeError: 'tuple' object does not support item assignment

n = int(input())
t = (1, 2, 3)

n in t

#tuple can be used in function to return multiple values
def func():
    name = "kim"
    year = 2024
    return name, year #tuple

a, b = func() #assign returned tuple
print(a)
print(b)

"""####4-4. Set"""

a = ['apple', 'banana', 'grape', 'orange']
print(a)
type(a)

a = set(['apple', 'banana', 'grape', 'orange', 'grape'])
print(a)
type(a)

a = set()
print(a)
a = set("Hello") #set does not allow duplicates, set is unordered
print(a)

a = set([1, 2, 3, 4, 5, 6])
b = set([4, 5, 6, 7, 8, 9])
print(a & b)
print(a.intersection(b))

print(a | b)
print(a.union(b))

print(a - b)
print(a.difference(b))

b.add(3)
b

b.update([1, 2])
b

b.remove(9)
b

"""####4-5. Dictionary

1) Dictionary Built-in Function
"""

#{Key1: Value1, Key2: Value2, Key3: Value3, ...}
dic = {'name': 'pey', 'month': 11, 'room': [101, 102, 103]}

dic.keys()

list(dic.keys())

dic.values()

dic.items() #returns dict_items object and uses tuple

dic.clear()
dic

d = {}
d[1] = 'A' #dic[key] = value
d['b'] = 2
d["cat"] = 3
print(d)   #print(d[0]) KeyError

del d['b'] #delete using key
d

d[(1, 2)] = 'H' #list cannot be key since it's changeable
d

d["cat"] #if no key returns error

d.get("dog") #if no key returns None

"cat" in d #search if there is a specific key in dic

"""2) Dictionary User-defined Function"""

#count each letters in string
def histogram(st):
  dic = dict()
  for ch in st:
    if ch not in dic: #check key in dictionary
      dic[ch] = 1  #initialize key : value
    else:
      dic[ch] += 1 #increase value
  return dic

result = histogram("sejongcampus")
print(result, end='')

#same as above, but used .get(key, default value)
def histogram2(st):
  dic = dict()
  for ch in st:
    dic[ch] = 1 + dic.get(ch, 0)
  return dic

result = histogram2("sejongcampus")
print(result, end='')

#use value to find key
def reverse_lookup(dic, val):
  for key in dic:
    if dic[key] == val:
      return key
  raise ValueError #creates error name

dic = histogram("SejongUniversitySeoulCampus")

reverse_lookup(dic, 1) #in dictionary 'j' : 1, so function returns 'j'

#make inverted dictionary
def invert_dict(dic):
  inverse = dict()
  for key in dic:
    val = dic[key]
    if val not in inverse:
      inverse[val] = [key] #create a list; many keys may have the same value
    else:
      inverse[val].append(key)
  return inverse

dic = histogram("SejongUniversitySeoulCampus")

invert_dict(dic)

'''memorization using dictionary'''
#sample function
def fibo(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fibo(n - 1) + fibo(n - 2)

#time check
import time

current = time.time()
current #returns sec from 1970.01.01

start = time.time()
fibo(30)
end = time.time()
print("The time required: {:.22f}".format(end - start))

#use dictionary to shorten time
known = {0:0, 1:1} #saved first two fibonacci values

def fibo2(n):
  if n in known:
    return known[n] #returns known dictoinary value, instead of calculating
  #if not in dictionary, save the value then returns
  result = fibo2(n - 1) + fibo2(n - 2)
  known[n] = result
  return result

start = time.time()
fibo2(30)
end = time.time()
print("The time required: {:.22f}".format(end - start)) #much faster when dictionary is used

#another sample function
def has_dups(st):
  dic = dict()
  #turn every input type to string type
  if type(st) == int or type(st) == float:
    st = str(st)
  #make every element in string lowercase
  if type(st) == str:
    st = st.lower() #this makes 'S' == 's'
  for ch in st:
    if ch not in dic: #create key : value
      dic[ch] = 1
    else:
      return True #confirmed there is a duplicate letter in string
  return False

has_dups(1233)

start = time.time()
has_dups("Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus")
end = time.time()
print("The time required: {:.22f}".format(end - start))

#more faster function, but not used dictionary
def has_dups2(st):
  if type(st) == str:
    sorted_st = sorted(st.lower())  #makes 'S' == 's'
  else:
    sorted_st = sorted(st) #use sorted for below if comparsion

  i = 0
  while i < len(sorted_st) - 1:
    if sorted_st[i] == sorted_st[i + 1]: #duplicate confirmed
      return True
    i += 1
  return False

start = time.time()
has_dups2("Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus Sejong uniersity Seou lcampus")
end = time.time()
print("The time required: {:.22f}".format(end - start))

"""### 5.Flow Control

####5-1. If Statements

1) Logical Operator
"""

x = 1
y = 3
print(x < y)
print(x > y)
print(x == y)
print(x != y)
print(x <= y)
print(x >= y)

(1 < 2) == False

"""2) Boolean Operator"""

x = 1
y = 2
print(x < y or x > y)
print(x < y and x > y)
print(not x < y)

"""3) If Conditional"""

x = 1
y = 2
if x > y:
  print("x is greater than y") #Indentation (by using with :, does not require {} and ;)
elif x < y:
  print("y is greater than x")
else:
  print("x equals y")

#nested if
x = 1
y = 2
if x == y:
  print("x and y are equal")
else:
  if x < y:
    print("x is less than y")
  else:
    print("x is greater than y")

n = input()

if n in ["kim", "lee", "park"]:
  print("They seem to be a Korean.")

b1 = False
b2 = True

if b1 is True:
  print("b%d: %s is true" %(1, b1))
elif b2 is True:
  print("b%d: %s is true" %(2, b2))
else:
  print("Neither is true")

"""4) Pass Statement"""

x = 2
if x == 2:
  pass #do nothing
else:
  print("wrong number")

"""####5-2. While Statements

1) While Loop
"""

i = 0
while i <= 3:
  print(i)
  i += 1

n = 0
while (n != 4):
  n = int(input())

"""2) Break Statement"""

j = 0
while True:
  print(j)
  j += 1
  if j > 5:
    break

j = 1
while j <= 5:
  print(j)
  j += 1
else:         #execute after while loop finished
  print("value reached: %d" %j)

j = 1
while True:
  print(j)
  j += 1
  if (j > 5): #while loop broken
    break
else:         #does not excute
  print("value reached: %d" %j)

def eval_calc():
  while True:
    line = input("Enter some mathmatical statement:")
    if line == "stop":
      break
    result = eval(line) #eval() if the expression is a legal Python statement, it will be executed.
    print(result)
  return result

eval_calc()

"""####5-3. For Statements

1) For Loop
"""

for i in [0, 1, 2]:
  print(i)

t = [(0, 1), (2, 3)]
for (a, b) in t:
  print(a + b)

s = [0, 1, 2, 3]
for j in s:
  print(j)

s = [0, 1, 2, 3]
for j in s: #print s, j times
  print(s)

t = ['a', 'b', 'c', 'd', 'e']
for i, j in enumerate(t):             #generates a tuple with index and value
  print(f"value at index {i} is {j}") #string format

n = ['Paul', 'Charles', 'Minji']
a = [25, 30, 29]

p = zip(n, a)   #to combine iterables into a single iterable, returns tuple

for i, j in p:
  print(f"{i} is {j} years old")

numlist = [1, 2, 3, 4, 5]
for i in reversed(numlist):
  print(i)

"""2) Continue Statement"""

for i in [1,2,3,4,5,6,7,8]:
  if i % 2 == 0:
    continue #go back to top
  print(i)

"""3) Range Built-in Function"""

for i in range(3): #starts from zero, ends before number
  print(i)

s = [1, 2, 3, 4, 5]
for i in range(len(s)):
  print(s[i])

start = 1
end = 4
for i in range(start, end): #[s, e)
  print(i)

s = 2
e = 10
for i in range(s, e, 2): #range(start, end, step)
  print(i)

for i in range(10):
  if i % 2 == 0:
    continue
  print(i)    #prints only odd numbers

"""### 6.Functions

####6-1. Built-in Function

1) Definition of Function:

Function: a named sequence of statements that performs a computation.

Functions take an argument and return results.

*Built-in / Module and Library / Anonymous and User-defined Functions*

2) Lists of Built-in Functions:

* abs() the absolute value of a number
* all()	True if all items in an iterable object are true
* any() True if any item in an iterable object is true
* ascii()	a readable version of an object: it replaces none-ascii characters with escape character
"""

abs(-33.3) #abs(x)

print(all([True, False, True])) #all(iterable)
print(any([True, False, True]))

"""* bin()	the binary string version of an integer number
* bool() the boolean value of the specified object
* bytearray()	a new array of bytes
* bytes()	a new bytes object
"""

print(bin(3)) #bin(x)
bool(0) #class bool(x)

text = "Python is joyful!!" #class bytes(source, encoding)
bytes(text, 'utf-8') #read-only (immutable) version of bytearray

bytearray(text, 'utf-8') #sequence of 1byte = 8bits = 0~255 (0x00~0xFF)

"""* callable() True if the specified object is callable, otherwise False
* chr()	the string representing a character whose Unicode codepoint is specific integer
* classmethod()	converts a method into a class method
* compile()	returns the specified source as an object, ready to be executed
* complex()	a complex number
"""

chr(65) #chr(i)

#compile(source, filename, mode, ...)
code = 'x = 10\ny = 20\nprint("Sum:", x + y)' #same indentation level
compiled_code = compile(code, filename= "example", mode= "exec")

#class complex(real=0, imag=0)
real_part = 3
imag_part = 4
complex(real_part, imag_part)

"""* delattr()	deletes the specified attribute (property or method) from the specified object
* dict() a dictionary
* dir()	a list of the specified object's properties and methods
* divmod() the quotient and the remainder when dividing two numbers
"""

#class dict(**kwarg)
x = dict(name = "Kim", age = 36, likes = "cat")
x

#divmod(a, b)
divmod(5, 2) #q and r

"""* enumerate()	takes a collection (like tuple) and returns it as an enumerate object
* eval()	evaluates and executes an expression
* exec()	executes the specified code (or object)
"""

#enumerate(iterable, start=0)
x = ('apple', 'banana', 'grape')
y = enumerate(x)
list(y)

#eval(expression, ...)
eval('print(55)')

#exec(object, ...) : object is either string or code-object
exec(compiled_code)

"""
* filter() use a filter function to exclude items in an iterable object
* float()	a floating point number
* format() formats a specified value
* frozenset() a frozenset object (unchangeable set)"""

# filter(function, iterable)
def is_even(num):
  return num % 2 == 0

numlist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(numlist)

print(list(filter(is_even, numlist)))
for n in filter(is_even, numlist):
  print(n)

#class float(x)
type(float('2.14'))

#format(value, format_spec='')

#positional formatting
print("Name: {}, Age: {}, Team: {}, Score: {}".format("John", 30, 20, 6.2))
#(named) placeholders
print("Name: {n}, Age: {a}, Team: {t}, Score: {s}".format(n= "John", a= 30, t= 20, s= 6.2))
print("Name: {0}, Age: {2}, Team: {1}, Score: {3}".format("John", 30, 20, 6.2))
#format specifiers
print("Name: {:!<5s}, Age: {:>04d}, Team: {:03d}, Score: {:.2f}".format("John", 30, 20, 6.2))

"""* getattr()	the value of the specified attribute (property or method)
* globals()	the current global symbol table as a dictionary
"""

#globals()
globalVar1 = "Hello"
globalVar2 = 100
globalVar3 = [10, 20, 30]

#print("globals in main:", globals())
#{..., globalVar1': 'Hello', 'globalVar2': 100, 'globalVar3': [10, 20, 30]}

"""* hasattr()	True if the specified object has the specified attribute (property/method)
* hash() the hash value of a specified object
* help() executes the built-in help system
* hex()	converts a number into a hexadecimal value string
"""

#hash(object)
data = "Python is interesting!"
hashed_data = hash(data)
print(data)
print(hashed_data)

#hex(x)
hex(15)

"""* id()	the id of an object
* input()	allowing user input
* int()	an integer number
* isinstance()	True if a specified object is an instance of a specified object
* issubclass()	True if a specified class is a subclass of a specified object
* iter() an iterator object
"""

#input()
a = input()
type(a)

#class int(x, base=10)
print(type(int(a)))
print(int(3.99))

"""* len()	the length of an object
* list()	returns a list
* locals()	an updated dictionary of the current local symbol table
"""

#len(s)
a = len("Python is great")
print(a)

#class list()
list("python")

"""* map()	the specified iterator with the specified function applied to each item
* max()	the largest item in an iterable
* memoryview() a memory view object
* min()	the smallest item in an iterable
* next()	the next item in an iterable
"""

#map(function, iterable)
def two_times(x):
  return x*2

list(map(two_times, [1, 2, 3, 4]))

print(max([1, 2, 3])) #max(iterable, ...)
print(min([1, 2, 3]))

"""* object() a new object
* oct()	converts a number into an octal
* open()	opens a file and returns a file object
* ord()	convert an integer representing the Unicode of the specified character
"""

#oct(x)
print(oct(8))

#ord(c)
print(ord('A'))

"""* pow()	the value of x to the power of y
* print()	prints to the standard output device
* property()	gets, sets, deletes a property
"""

#pow(base, exp, ...)
print(pow(2, 4))

#print(*objects, sep=' ', end='\n', ...)
print(0, 1, 2, 3, 4, sep='*', end='!')
print(5)

"""* range()	a sequence of numbers, starting from 0 and increments by 1 (by default)
* repr()	a readable version of an object
* reversed() a reversed iterator
* round()	rounds a numbers
"""

#class range(start, stop, step=1)
list(range(0, 6, 2))

#reversed(seq)
list(reversed([1, 7, 5, 3, 9]))

#round(number, ndigits=None)
print(round(3.5))
print(round(3.575, 2))

"""* set()	a new set object
* setattr()	sets an attribute (property/method) of an object
* slice()	returns a slice object
* sorted() a sorted list
* staticmethod()	converts a method into a static method
* str()	a string object
* sum()	sums the items of an iterator
* super()	an object that represents the parent class
"""

#class set()
set([1, 2, 3, 5, 3])

#class slice(start, stop, step=None) : does not alter the original array
a = "1234"
b = "5678"
cut = slice(1, 3)
print(a[cut])
print(a)
print(b[cut])
print(b)

#sorted(iterable, ..., key=None, reverse=False)
s = [1, 9, 7, 3, 5]
s = sorted(s, reverse=True) #.sort() can be used only in list, also does not return value
s

#class str(object)
str(3987)

#sum(iterable, ..., start=0)
sum([1, 2, 3], start=10)

"""* tuple()	a tuple
* type()	the type of an object
"""

#class tuple(iterable)
tuple("abc")

#class type(object)
type(open("test", 'r'))

"""* vars()	the dict property of an object
* zip()	an iterator, from two or more iterators
"""

#zip(iterables, ...)
list(zip("abc", "defg"))

#in zip(), * operator can be used to unzip:
x = [1, 2, 3]
y = ['a', 'b', 'c']

res = list(zip(x, y))
print(res)

a, b = zip(*res)
print(a)

"""####6-2. Module Function

1) Math Module

Module: is a simple Python file that contains collections of functions and global variables and with having a .py extension file.

Package: is a simple directory having collections of modules.

Library: is having a collection of related functionality of codes that allows you to perform many tasks without writing your code.
"""

#import sys
#sys.modules #to check if the module has already been loaded

import math #means include
print(math)

"""A. Number-theoretic Functions"""

print(math.ceil(2.3))
print(math.floor(2.3))

print(math.gcd(4, 12)) #the greatest common divisor
print(math.lcm(4, 12)) #the least common multiple

print(math.perm(5, 2)) #nPk n! / (n - k)!
print(math.comb(5, 2)) #nCk n! / (k! * (n - k)!)

#a float consisting of the value of the first parameter and the sign of the second parameter
math.copysign(3, -1)

#the fractional and integer parts of x. both carry the sign of x and are floats.
math.modf(3.75)

#the fractional part removed, leaving the integer part
print(math.trunc(3.75))
print(math.trunc(-3.75))

#the absolute value of a number
math.fabs(-1)

#the remainder of x/y
math.fmod(4, 3)

#the sum of all items in any iterable (tuples, arrays, lists, etc.)
math.fsum([1, 2, 3, 4])

#the product of all the elements in the input iterable. default start value for the product is 1.
math.prod([1, 2, 3, 4])

math.factorial(3)

"""B. Power and Logarithmic Functions"""

print(math.sqrt(4)) #square root

print(math.log2(8))
print(math.log10(10))

print(math.pow(2, 3))

"""C. Trigonometric Functions"""

print(math.sin(0))
print(math.cos(0))
print(math.tan(0))

#the Euclidean distance between two points p and q. must have the same dimension.
math.dist([3], [2])

"""D. Angular conversion"""

print(math.degrees(2 * math.pi))
print(math.radians(180)) #r = (d / 180) * pi

"""E. Constants"""

print(math.pi)
print(math.e)

"""2) Import Keyword

* as : to create an alias
"""

import math as m #rename module.
m.pi

"""* from : to import specific parts of a module"""

from math import pi #use without module.
print(pi)
from math import sqrt
print(sqrt(4))

from math import * #all
print(ceil(1.9))

from math import pi as p
print(p)

"""3) Numpy Module"""

import numpy as np #a Python library used for working with arrays.

"""* numpy.arange(start, stop, step) : return an array with evenly stepped values within [start, stop)."""

np.arange(0, 1, .2)

"""* numpy.linspace(start, stop, num) : return an array with evenly spaced num samples within [start, stop]."""

np.linspace(0, 1, 11)

"""####6-3. User-defined Function

1) Anonymous Function (Lambda)

> lambda parameter : expression
"""

"""
def square(x):
  return x * x
"""
sqr = lambda x : x * x
sqr(4)

cube = lambda x : x * x * x
cube(3)

add = lambda a, b : a + b
add(2, 3)

(lambda x : x + 3)(4)

#with filter() function
list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4])) #cascade functions

#with map() function
list(map(lambda x: x**2, [1, 2, 3, 4]))

#with sorted() function
sorted([6, 2, 4, 1], key = lambda x: x) #key = what standard

#using lambda to create factorial without recursion
def factorial(n, f = lambda x : x): #f is default value argument
  k = 1
  for i in range(f(n)):
    k = k * (i + 1)
  return k

factorial(5)

"""2) User-defined Function Structure

def func_name(parameter1, ...):
> statement1...

> return expression

func_name(argument1, ...)
"""

def summation(a, b):
  return a + b

summation(1, 2)

def increment(x):
  return x + 1

increment(2)

def temp():
  pass      #define a function without doing anything

temp()

def check(x):
  '''This function is to check whether even or odd''' #docstring
  if (x % 2 == 0):
    print("It is an even integer!")
  else:
    print("It is an odd integer!")

check(4)

def write_text(arg1, arg2):
  print("Hello, %s and %s!" %(arg1, arg2))

write_text("Kim", "Lee")

#local variable (in function)
#global variable (in main function)
a = 1
def change(a):
  a += 1
  print("loc:", a) #local

change(a)
print("glo:", a)   #global

#functions may call each other
def repeat_text():
  print_text()
  print_text()

def print_text():
  print("Sejong University")

repeat_text()

#function with for loop
def isprime(x):
  for i in range(2, x):
    if x % i == 0:
      return False
  return True

isprime(17)

#function with while loop
def octtodec(x):
  result = 0
  base = 1
  while (x):
    last_digit = x % 10   #taking off a digit
    x = int(x / 10)       #removing the digit
    result += last_digit * base
    base = base * 8
  print(result)

octtodec(101)

#define a function within a function
def multipleS(x, y):
  m = x * y
  def square(z):
    return z * z
  return square(m)

multipleS(3, 4)

"""3) Arguments of Function"""

#argument order designation
def func1(a, b):
  return a - b

print(func1(1, 2))
print(func1(b = 1, a = 2))

#default argument value designation
def func2(arg1, arg2 = "apple"):
  print("I like %s and %s." %(arg1, arg2))

func2("pizza")
func2("pizza", "banana")

# SyntaxError: non-default argument follows default argument
# def func3(arg1 = "apple", arg2):
#   print("I like %s and %s." %(arg1, arg2))

#list of arguments
def func(arg):
  for x in arg: #function will not be executed until its called
    print(x)

arg = ["Park", "Lee", "Choi"]
func(arg)       #function call

#multiple arguments
def func3(*args):
  print(args[0]) #among arguments, print the first one using index

func3("arg1", "arg2", "arg3")

#multiple keyword arguments
def func4(**kwargs):
  print(kwargs)

func4(Lee = 201) #sending arguments with Key = Value syntax
func4(Kim = 301, Park = 101)

def func5(**kwargs):
  print(kwargs["Lee"]) #print the value with this key

func5(Kim = 301, Lee = 201, Park = 101)

"""4) Recursive Function

* a function that solves a problem by solving smaller instances of the same problem.
"""

def power(a, n):
  if n == 0:
    return 1
  elif n == 1:
    return a
  else:
    return a * power(a, n - 1)

power(2, 3)

def powertwo(t):
  if t == 0:
    return 1
  else:
    return 2 * powertwo(t - 1)

powertwo(5)

def gcd(a, b):
  if (b == 0):
    return a
  else:
    return gcd(b, a % b)

gcd(16, 24)

def lcm(x, y):
  z = x % y
  if z == 0:
#   print(x, y, z)
    return x
# print(x, y, z)
  return int(x * lcm(y, z) / z) #4 * 3 / 1 | 11 * 12 / 3

lcm(4, 11)

def factorial(n):
  if n == 1 or n == 0:
    return 1
  else:
    return n * factorial(n - 1)

factorial(4)

def fibonacci(n):
  if n <= 1:
    return n
  else:
    return fibonacci(n - 1) + fibonacci(n - 2)

n = int(input("n= "))

if n <= 0:
  print("not possible")
else:
  for i in range(n): #starts from n = 0, ends at n = 6
    print(fibonacci(i))

def reverse(s):
  if len(s) == 0:
    return s
  else:
#   print(s)
    return reverse(s[1:]) + s[0]

s = "sejong"
print(reverse(s))

"""###7.Files

####7-1. File object related Functions

open(): Opens a file in given access mode

close(): Used to close an open file

>Mode in File object related function

'r' : open for reading (default)

'w' : open for writing, truncating the file first

'x' : open for exclusive creation, failing if the file already exists

'a' : open for writing, appending to the end of file if it exists

'b' : binary mode

't' : text mode (default)

'+' : open for updating (reading and writing)

with statement: Unlike open() where you have to close the file with the close() method, the with statement closes the file for you without you telling it to.
"""

with open('test.txt', 'w') as f1:
  f1.write("Hello Sejong!\n")
  f1.write("This is from Sejong University.\n")

with open('test.txt', 'r') as f1:
  text = f1.read()

print(text)

f1 = open('test.txt', 'a')
f1.write('something\n')

f1 = open('test.txt', 'r')
print(f1.readlines())
print()

""">File obejct related Methods

.read(): reads the entire file and returns it contents in the form of a string.

.write(): writes the contents of string to the file.

.readline(): returns one line from the file.

.readlines(): reads all lines in the file, and updates each line to a list, which is returned.

.writelines(sequence): sequence is usually a list of strings or any other iterable data type.
"""

f2 = open('myfile.txt', 'w')

L = ["This is the first line.\nThis is the second line.\nThis is the third line.\n"]
f2.write("Header\n")
f2.writelines(L)

f2 = open('myfile.txt', 'r')

print(f2.read())
print()

print("output of read(9) function is")
print(f2.read(9)) #read only n bytes
print()

""".seek(offset, from_where): used to change the file object's position."""

f2.seek(10)

print("output of readline function is")
print(f2.readline())
print()

print("output of readline function is")
print(f2.readline(9))  #read only n bytes in the line
print()

print(f2.readlines())
print()

"""####7-2. Error and Exception handling"""

try:
  f3 = open('nofile.txt')
  for line in f3:
    print(line)
  f3.close()
except:
  print('something is wrong') #

"""####7-3. File directory Paths"""

import os

cwd = os.getcwd() #current working directory
print(cwd)

!ls #list files

os.path.abspath('example.txt') #'example.txt' file stored in absolute path

os.listdir(cwd) #list files in cwd

"""####7-4. Connecting Google Drive"""

from google.colab import drive
drive.mount('/content/drive')

!ls

f4 = open('/content/drive/MyDrive/Colab Notebooks/words_alpha.txt')

print(f4)

f4.readline()

line = f4.readline()
word = line.strip() #remove whitespace(space, linebreak..) from front and rear
print(word)

i = 0
for line in f4:
  if i == 4:
    break
  word = line.strip()
  print(word)
  i += 1

"""####7-5. Database Management

DataBase Manager: dbm stores data in simple key-value pair form like a dictionary, making it easier to insert, edit and retrieve data from the database.
"""

import dbm

"""dbm.open(): to open a dbm database or create a new database if not exist.

‘r’: open the existing database with permission to read only.

‘w’: open the existing database with permission to read and write.

‘c’: open the database for read and write, also create a new one if it doesn’t exists.

‘n’: always create a new database with permission to both read and write.
"""

db1 = dbm.open('captions.db', 'c')

db1['sejong.png'] = 'photo of sejong'

print(db1['sejong.png']) #saved in bytearray

db1['sejong.png'] = 'photo of king sejong'

print(db1['sejong.png'])

db1.close()

"""####7-6. Pandas Library

Pandas is open source data analysis and manipulation tool.
"""

import pandas as pd

#Loads the CSV format file into a DataFrame
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Testdata.csv')
#df will be Two-dimensional tabular data.

df.describe() #.describe() is used to view some basic statistical details (view metadata)

df #view the dataframe itself

"""###I. Practices 1

####3/19: Function
"""

'''
Q01. Code a program to list out prime numbers less than 100
'''

def prime_num(n):
  isp = 1
  if (n < 2):
    isp = 0
  else:
    for i in range(2, n):
      if n % i == 0:
        isp = 0
        break
  return isp

print(list(filter(prime_num, range(1, 100))))

"""####3/26: List"""

'''
Q01.
Write an function that takes four parameters: a, b, c and n
and that checks to see if n is greater than 2 and it turns out to be true,
that a^n + b^n = c^n
the program should print, "Yes, it works!"
Otherwise the program should print, "No, it doesn't work."
'''

def checker(a, b, c, n):
  if (n > 2):
    if (a**n + b**n == c**n):
      print("Yes, it works!")
    else:
      print("No, it doesn't work.")
  else:
    print("N must be greater than 2.")

a = int(input("a: "))
b = int(input("b: "))
c = int(input("c: "))
n = int(input("n: "))

checker(a, b, c, n)

def checker2(a, b, c, n):
  if n <= 2:
     print("N must be greater than 2.")
     return
  elif (a**n + b**n == c**n):
    print("Yes, it works!")
  else:
    print("No, it doesn't work.")

'''
Q02.
Write a function called is_sortted that takes a list as a parameter
and returns True if the list is sorted in ascending order
and False otherwise.
'''

def is_sorted(li):
  sli = sorted(li)
  if sli == li:
    return True
  else:
    return False

li = [5, 1, 3, 7, 9]
is_sorted(li)

def is_sorted2(li):
  for i in range(len(li) - 1):
    if (li[i] > li[i+1]):
      return False
  return True

li = [1, 3, 7, 9]
is_sorted2(li)

'''
Q03.
Two words are anagrams if you can rearrange the letters from one to spell the other.
Write a function called is_anagram that takes two strings and
returns True if they are anagrams.
hint: need to check if it is a subset
'''

def is_anagram(st1, st2):
  max = len(st1)
  cnt = 0
  for i in range(len(st1)):
    for j in range(len(st2)):
      if st1[i] == st2[j]:
        cnt += 1
  return cnt == max

is_anagram("cat", "act")

def is_anagram2(st1, st2):
  if len(st1) != len(st2):
    return False
  for char in st1:                   #c -> a -> t
    if char not in st2:
      return False
    else:                            #string.replace(old, new, times)
      st2 = st2.replace(char, '', 1) #act -> at -> t ->
  return True

is_anagram2("cat", "act")

'''
Q04.
Write a function called has_duplicates that takes a list
and returns True if there is any element that appears more than once.
It should not modify the original list.
'''

def has_duplicates(li):
  for i in range(len(li)):
    for j in range(len(li)):
      if li[i] == li[j] and i != j:
        return True
  return False

has_duplicates([1, 2, 3, 4, 2, 4])

def has_duplicates2(li):
  checked = set()         #{ }: a set does not allow duplicates
  for el in li:
    if el in checked:     #if list element is already in set
      return True
    else:
      checked.add(el)     #add element to the set
  return False

has_duplicates2([1, 2, 3, 4, 2, 4])

'''
Q05.
Write a function called most_frequent that takes a string
and prints the letters in decreasing order of frequency.
'''

def most_frequent(st):
  dic = dict()
  for i in range(len(st)):
    cnt = 1
    for j in range(len(st)):
      if (st[i] == st[j] and i != j):
        cnt += 1
    dic[st[i]] = cnt
  return dic

dic = most_frequent("Sejong Student")
sorted(dic.items(), key = lambda x: x[1], reverse = True) #items(key : value), x[1] means value (x[0] means key)

for i in dic:
  print(i, dic[i])

def most_frequent(st):
  letters = list(st)
  count = {}        #make a dictionary

  for i in letters: #char list
    if i in count:  #key is already in a dictionary
      count[i] += 1 #value + 1
    else:
      count[i] = 1

  sort = sorted(count, key = lambda x : count[x], reverse = True) #sort dic by value in rev order

  for i in sort:
    print(i, count[i])

most_frequent("Sejong Student")

"""####4/02: Iteration

>Iteration
"""

#iterate over a list of numbers and print each one
lst = [1, 2, 3, 4]
for i in lst:
  print(i)

#iterate over a string and print each character
st = "Python"
for i in st:
  print(i)

#iterate over a range of numbers and print each one
for i in range(5):
  print(i)

#use 'for loop' to print a 1 to 5 but not 3
for i in range(1, 6):
  if (i == 3):
    continue
  else:
    print(i)

#use 'while loop' to print odd numbers from 1 to 10
i = 1
while (i <= 10):
  if (i % 2 == 1):
    print(i)
  i += 1

#print only some of letters of a word, e.g, the first 3 letters
st = "Python"
for i in st:
  if i == 'h':
    break
  print(i)

#use 'while loop' and 'break' to print 10 to 6
i = 10
while (i > 0):
  if i == 5:
    break
  print(i)
  i -= 1

#use 'for loop' and 'continue' to print only selected letters in a word
st = "student"
for i in st:
  if i == 's' or i == 't':
    continue
  else:
    print(i)

#use an 'else statement' with a 'for statement' to search for prime numbers from 10 through 20
for num in range(10, 21):
  for i in range(2, num):
    if num % i == 0:
      j = num / i
      print("%d equals %d * %d" %(num, i, j))
      break
  else: #from for loop, if not ended with break,
    print(num, "is a prime number")

#use 'for loop' and 'pass' to write a 'command message' between printing a string
for i in "python":
  if i == 'h':
    pass
    print("This is pass block")
  print(i)

""">Numpy"""

import numpy as np

'''
np.arange(start, stop, step) : Return evenly spaced values within a given interval.
Values are generated within the half-open interval [start, stop), with spacing between values given by step.
'''

#use a for loop to print from np.arange()
for i in np.arange(1, 6, 0.5):  #step = 0.5
  print(i, end=' ')

'''
np.linspace(start, stop, num) : Returns num evenly spaced samples, calculated over the interval [start, stop].
'''

#use for loop to traverse an np.linspace()
for i in np.linspace(1, 6, 5):  #5 numbers
  print("{:.1f}".format(i))

#use 'arange()' to create sequence of values between 0 and 20 where spacing is 2
np.arange(0, 20, 2)

#also works with negative numbers
np.arange(-10, -2) #default step = 1

#use 'linspace()' to create sequence of 11 evenly spaced values between 0 and 20
for i in np.linspace(0, 20, 11):
  print(i, end=' ')

'''
np.arrray() : create an n-dimensional array
'''

c = np.array([[0, 1], [2, 3], [4, 5]])
print(c)

print(c[0][1])

#Returns the data type
c.dtype

print(len(c))     #number of rows
print(len(c[0]))  #number of columns

#Returns the elements of the shape tuple containing the number of rows and columns
np.shape(c)

#Returns the dimension of an array
np.ndim(c)

#Returns the total number of elements in an array
np.size(c)

#Returns an array of row, column filled with 0.
b = np.zeros((2, 4)) #careful with parenthesis.
b

#Returns an array of row, column filled with 1. (Unit Matrix)
a = np.ones((2, 4)) #careful with parenthesis.
a

x = np.array([[1, 2], [3, 4]])

#Return an array of ones with the same shape and type as a given array.
e = np.ones_like(x)
print(e)

#Return an array of zeros with the same shape and type as a given array.
f = np.zeros_like(x)
print(f)

#Return a new array of given shape and type, without initializing entries.
y = np.empty((2, 2)) #careful with parenthesis.
print(y)

#N-D array Slicing
s = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]])

v = s[1:, 1:4] #row slice, column slice
v

#for loop for matrix multiplication
A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])           #n * m
B = np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]])  #m * k

M = np.zeros((A.shape[0], B.shape[1]))                    #n * k matrix filled with zeros

for i in range(A.shape[0]):       #A.shape[0] : returns the number of rows in array A.
  for j in range(B.shape[1]):     #B.shape[1] : returns the number of columns in array B.
    for k in range(B.shape[0]):   #M[i][j] += A row i element * B column j element
      M[i][j] += A[i][k] * B[k][j]

print(M)

""">Built-in"""

#enumerate() to print an enumerate object
n = ['Do', 'Re', 'Mi']

for c, n in enumerate(n, start= 1):
  print(f"{c}, {n}")

#zip() to print two lists together
for item in zip([1, 2, 3], ['sugar', 'spice', 'salt']):
    print(item)

"""####4/09: String"""

'''
Q01. Encrpytion:
Write a function that takes a string and an integer as parameters,
and returns a new string that contains the letters from the original string 'rotated' by the given amount.
'''

def rotate(string, n):
  rotated = ''
  for char in string:
    if char.isalpha(): #if char is alphbet,
      rotated += chr((ord(char) - ord('a') + n) % 26 + ord('a')) #(ord(char) - ord('a') + n) % 26 = rotate value
    else:
      rotated += char
  return rotated

rotate('cheer', 7)

'''
Q02.
Write a function that returns True
if the given word doesn't have the letter 'e' or 'E' in it.
'''

def check_for_letter(string):
  if 'e' in string:
    return True
  elif 'E' in string:
    return True

check_for_letter("sejong")

def look_for_e(word):
  for letter in word:
    if letter == 'e' or letter == 'E':
      return False
    return True

look_for_e("sejong")

'''
Q03.
Write a function that takes a word and a string of required letters,
and returns True if the word uses all the required letters at least once.
'''

def search_letter(word, letters):
  flag = 0
  for i in range(len(word)):    #end checking
    if flag == len(letters):
      break
    for j in range(len(letters)):
      if word[i] == letters[j]: #no more checking
        flag += 1
        break
  return flag == len(letters)

search_letter("apple", "app")

def uses_all(word, required):
  for letter in required:
    if letter not in word:
      return False
  return True

uses_all("Orange", ["a", "e"])

'''
Q04.
Abecedarian:
Write a function that returns True,
if the letters in a word appears in alphabetical order (double letters are ok).
'''

def is_abecedarian(word):
  flag = 1
  for i in range(len(word) - 1):
    if (ord(word[i]) > ord(word[i + 1])):
      flag = 0
      break
  return flag

print(is_abecedarian("abcde"))
print(is_abecedarian("paul"))
print(is_abecedarian("app"))

def is_abecedarian(word):
  for i in range(len(word) - 1):
    if word[i + 1] < word[i]:
      return False
  return True

is_abecedarian("air")

'''
Q05. Write a code to break a string into individual elements
'''

s = "sejong university is in seoul"
t = s.split()
t

'''
Q06. Write a code to segmentize a sentence based on a specific delimiter
'''

s = "sejong-university-spring"
t = s.split('-')
t

'''
Q07. Write a code to demonstrate join() as the inverse of split()
'''

s = ['sejong', 'university', 'is', 'in', 'seoul']
delimiter = '-'
delimiter.join(s)

'''
Q08. Write a code to delete the first element in list
'''

def func(t):
  del t[0]

a = ['a', 'b', 'c']
func(a)
print(a)

'''
Q09. Write a code to take a list as an argument and append all elements from another list to the list
'''

t1 = ['a', 'b', 'c']
t2 = ['d', 'e']

t1.extend(t2)
t1

'''
Q10.
Write a function that takes a list of numbers and returns the cumulative sum.
'''

def cumulative_sum(s):
  r = []
  i = 1
  while i <= len(s):
    r.append(sum(t[:i]))
    i += 1
  return r

t = [1, 3, 5]
cumulative_sum(t)

'''
Q11. Password generator:
design a password generator that creates strong passwords
using string manipulation to combine characters from different character sets
also limit password length given by user
'''

""">string module"""

import string

#returns string constants of...
string.ascii_lowercase
string.ascii_uppercase
string.ascii_letters
string.digits
string.hexdigits    #0123456789abcdefABCDEF
string.punctuation  #!"#$%&'()*+, -./:;<=>?@[\]^_`{|}~

""">random module"""

import random

#returns float value in [0, 1)
a = random.random()
print(a)

#returns int value in [start, stop)
b = random.randrange(1, 7)
print(b)

#shuffles the given sequence
c = [1, 2, 3, 4]
random.shuffle(c)
print(c)

#returns random element in given list
d = [1, 3, 5, 7, 9]
random.choice(d)

import random
import string

def pass_word(length):
  char_pool = string.ascii_letters + string.digits + string.punctuation
  password = ''.join(random.choice(char_pool) for i in range(length))
  return password

length = 12
print(f"Generated password: {pass_word(length)}")

'''
Q12.
Write a code that segments a paragraph into sentences,
employing string manipulation to identify sentence boundaries based on punctuation
'''

""">re module"""

import re #provides support for regular expression operations

#returns a list of splitted string
'''
re.split(pattern, string, ...)
'''
'''
r      : denotes a raw string literal
'''
#meta characters: a character that has a special meaning during pattern processing
'''
[.!?]  : a period, exclamation mark, or question mark
(?<= ) : checks if the current position is preceded by, in this case: a period, exclamation mark, or question mark
 +     : one or more occurrences of the preceding pattern, in this case: ' '
'''

import re

def func(paragraph):
  sentences = re.split(r'(?<=[.!?]) +', paragraph)
  return sentences

paragraph = "This is a sample paragraph. It contains multiple sentences! Isn't it interesting?"
print(f"Segmented sentences: {func(paragraph)}")

'''
Q13.
Write a code that identifies palindromes within a given text
by utilizing string manipulation to compare reversed strings with their originals
'''

def palindrome(string):
  return string == string[::-1]

text = "radar python level kayak"
words = text.split()

text_pal = [w for w in words if palindrome(w)]

print(f"Palindromes in text: {text_pal}")

"""####4/16: Dictionary"""

#create a dictionary and print the number of values along with the list of values
dic = {1: "a", 2: "b", 3: "c"}
for i in dic:
  print(i, dic[i])

d1 = dict(a=1, b=2, c=3)
values = d1.values()

print(len(values))
list(values)

#create two dictionaries and find common keys between two dictionaries
dic1 = dict(a=1, b=2, c=3)
dic2 = dict(a=2, c=4, d=5)

dkey1 = dic1.keys()
dkey2 = dic2.keys()

for i, j in zip(dkey1, dkey2):
  if i == j:
    print(i)

d1 = dict(a=1, b=2, c=3)
d2 = dict(b=20, d=40, e=50)
d1.keys() & d2.keys() #intersection

#find all keys of two dictionaries
d1.keys() | d2.keys() #union

from collections import defaultdict #default dict: no key error, returns empty list

d= defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(3)
d['b'].append(4)
d

#create a dictionary with default values
from collections import defaultdict

my_dict = defaultdict(lambda: "out of range!")
print(my_dict['a']) #no key

my_dict['b'] = "New"
print(my_dict)  #first arg provides the initial value for the default; it defaults to None

#create a multidic, i.e, maps keys to more than one value
d3 = {
    "a" : [1, 2, 3],
    "b" : [4, 5]
} #each key has multiple values

d3

#we can use a library to construct multidicts
from multidict import MultiDict #another way (need package installer of python)

md = MultiDict()
md.add('a', 1)
md.add('a', 2)
md.add('b', 3)
md.add('b', 4)
print(md)

values = md.getall('a')
print(values)

value = md['a'] #first value
print(value)

second_value = values[1]
print(second_value)

from collections import OrderedDict #to keep the inserted order of items when iterating
d = OrderedDict()
d['a'] = 1
d['b'] = 2
d['c'] = 3

for key in d:
  print(key, d[key])

#create a dictionary and find min(), max(), and sort() the values.

d4 = {'z': 10, 'b': 40, 'c': 30, 'd': 50}

min_price = min(zip(d4.values(), d4.keys()))
print(min_price)

max_price = max(zip(d4.values(), d4.keys()))
print(max_price)

sort_price = sorted(zip(d4.values(), d4.keys()))  #.values()
print(sort_price)

sort_price2 = sorted(zip(d4.keys(), d4.values())) #.keys()
print(sort_price2)

#create two dictionaries and add the second one to the first one
dic1 = dict(a= 1, b= 2, c= 3, d= 4)
dic2 = dict(c=0, e= 5, f= 6, g= 7, h= 8) #value of c will be updated

dic1.update(dic2)
dic1

#create a multi-level dictionary
a = {'a': 1, 'b': {'A': -1, 'B': -2}, 'c': 3}
a

my_dict = {
    'student1': {'name':'pete', 'age':20},
    'student2': {'name':'pike', 'age':21},
    'student3': {'name':'paul', 'age':22}
} #four dicts
print(my_dict['student1']['name'])

#create a dictionary from two lists
keys = ['a','b','c']
values = [1, 2, 3]

dic = {k: v for k, v in zip(keys, values)} #key: val for key, val
print(dic)

#create a dictionary using dictionary comprehension to calculate squares of numbers
lis = [1, 2, 3, 4, 5, 6]
sql = []
for i in lis:
  sql.append(i * i)
print(sql)

dic = {num: sqr for num, sqr in zip(lis, sql)}
print(dic)

squares = {num: num*num for num in range(1, 10)}
squares

#make a dictionary and try to group data based on the similar values
data = [('Lee', 'A+'), ('Park', 'B+'), ('Choi', 'A+'), ('Han', 'B+')]
grouped_data = {}

for name, grade in data:
  if grade not in grouped_data:
    grouped_data[grade] = [] #create key: value list
  grouped_data[grade].append(name)

print(grouped_data)

#use dictionary to count the frequency of elements in a list
data = [0, 1, 2, 3, 4, 1, 2, 2, 3, 4]
freq_table = {}

for item in data:
  if item not in freq_table:
    freq_table[item] = 0
  freq_table[item] += 1

print(freq_table)

#create a nested dictionary (contact information like name, phone number, address etc)
data = {
    'p1': {
      'name':'park',
      'age': 30,
      'contact' : '02-0687-8451'
    },
     'p2': {
      'name':'lee',
      'age': 40,
      'contact' : '02-0187-0251'
    },
}

data

#why is the output of the following code is like this?
num = 5
def factorial(n):
  global num
  num += 1
  if n == 1:
    return 1
  else:
    return n * factorial(n - 1)

print(num)
print(f"factorial of {num} is {factorial(num)}") #n == 5
print(num) #global

#a contact book application where you can add, remove, and search for contacts using a dictionary.
contacts = {}

def dic_add(key, val):
  contacts[key] = val

def dic_rem(key):
  contacts.pop(key, None)

def dic_ser(key):
  return contacts.get(key, "not found")

dic_add("lee", "010-1115-4454")
dic_add("kim", "010-8745-4574")
print(contacts)

dic_rem("lee")
print(contacts)

print(dic_ser("kim"))

#a reverse lookup function that finds all  keys with the same value in a dictionary
def reverse_lookup(dictionary, value_to_find):
  keys_with_value = [key for key, value in dictionary.items() if value == value_to_find]
  return keys_with_value

my_dict = {'a': 1, 'b': 2, 'c': 1}

reverse_lookup(my_dict, 1)

#create a family tree using dictionary
family_tree = {}

def add_family_member(path, member):
  node = family_tree #dictionary
  for key in path:
    node = node.setdefault(key, {}) #if no key, create key : default value
  node[member] = 'Kim'

add_family_member(['grandparent', 'parent'], 'child')
print(family_tree)

"""####4/23: Files"""

from google.colab import drive                      #link google drive to colab
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks/Testy') #change directory

'''Q1.
write a code to open a file and read the contents.
'''
f = open('tester.txt', 'w')
f.write('Hello')
f.close()

f = open('tester.txt', 'r')
f.read()

'''Q2.
write a code to write data to a csv file
involving handling delimeter characters and ensuring proper formatting.
'''
import csv

data = [['Name', 'Age'], ['Lee', 23], ['Park', 20]]

with open('data.csv', 'w', newline = '') as file:
  wr = csv.writer(file) #use csv.writer
  wr.writerows(data)    #to write rows

'''Q3.
rename multiple files using iterative over files
in a directory and applying renaming rules,
e.g. to change the files in a directory
to a similr name format like file1, file2'''
!ls

dir = '/content/drive/My Drive/Colab Notebooks/Testy'
cnt = 1

for filename in os.listdir(dir):
  if filename.endswith('txt'):      #string method.endswith(postfix, start, end)
    new_filename = f'file{cnt}.txt' #create new file names
    os.rename(os.path.join(dir, filename), os.path.join(dir, new_filename)) #rename files using os.rename(src, dst)
    cnt += 1                                                                #using together with os.path.join(path, *paths)

!ls

'''Q4.
write a code to copy one image to another image
'''
def CopyFile(input, output):
  try:
    with open(input, 'rb') as input_file:   #reads picture file1 in binary format
      bin_data = input_file.read()
    with open(output, 'wb') as output_file: #writes picture file2 in binary format
      output_file.write(bin_data)
    print(f"File copied from {input} to {output}.")
  except Exception as e:         #try ... except: for handling all exceptions
    print(f'Eroor Occured: {e}')

CopyFile('img1.jpg', 'img2.jpg')

!ls

'''Q5.
write a function that takes arguments a pattern string,
a replacement string, and two filenames;
/it should read the first file and write the contents into the second file
(creating it if necessary).
/If the pattern string appears anywhere in the file,
it should be replaced with the replacement string.
/If an error occurs while opening, reading, writing or closing files,
your program should catch the exception, print an error message, and exit.
'''

f = open('Search.txt', 'r')
words = f.read()
words

words = words.split(' ')

for i in range(len(words)):
  if words[i] == 'Seoul':
    words[i] = 'Busan'

rewords = ' '.join(words)
rewords

def replace_text(pattern, replacement, input_filename, output_filename):
  try:
    with open(input_filename, 'r') as input_file:
      content = input_file.read()
    modified_content = content.replace(pattern, replacement) #.replace(old, new)
    with open(output_filename, 'w') as output_file:
      output_file.write(modified_content)
    print(f"Patter '{pattern}' replaced with '{replacement}'.")
  except FileNotFoundError:
    print(f"Error: File '{input_filename}' not found.")
  except Exception as e:        #other errors
    print(f"Error: {e}")
  finally:
    print("Process completed.") #always executed

old = "Seoul"
new = "Busan"
replace_text(old, new, 'Search.txt', 'SearchR.text')

'''Q06.
write a code to encrpyt a text file and save it as a new file
'''
from cryptography.fernet import Fernet #fernet uses Symmetric key for encryption and decryption.

key = Fernet.generate_key() #generates key
cipher = Fernet(key)        #object(named cipher) can be used to encrypt plaintext or decrypt ciphertext

with open('secret.txt', 'rb') as file:  #read file as bytes type binary file
  data = file.read()
  encrypted_data = cipher.encrypt(data) #.encrypt() data using cipher object

with open('secret_encrypt.txt', 'wb') as file:
  file.write(encrypted_data)

print(key)
print(type(cipher))

"""###II. Assignment Projects 1

####3/26: Meaningful Word Finder
"""

'''
P01.
Find all meaningful words that are generated from letters of another word.
Download a data set of english words
Take out letters from user input word to make combinations of new words
Check which of them are available in the downloaded dictonary data
'''

from google.colab import drive                      #link google drive to colab
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks') #change directory

def downloaded_data():
    with open('words_alpha.txt') as f: #with: file open and auto close
        return f.read().split()        #read() returns string of the file content, split() to make a list

vocalist = downloaded_data()

from itertools import permutations     #itertools.permutations(iterable,r=None(default is max))

mstr = input()
wordlist = []

for ch in permutations(mstr):
  wordlist.append(''.join(ch))         #join() chars to make a word, append() the word to the list

wordlist = set(wordlist)               #erase duplicates
print(wordlist)

reallist = []

for word in wordlist:        #from the generated words
  if word in vocalist:       #if it is a real word (checked from data set)
    reallist.append(word)

print(reallist)

'''
P02.
What is the longest English word, that remains a valid English word,
As you remove its letters one at a time?
'''

def remove_letter(word):
  removed_list = []
  for i in range(len(word)):
    new_word = word[:i]           #remove i letters from the word
    removed_list.append(new_word) #add the new word to the removed word list
  return removed_list

removedlist = remove_letter("researcher")
print(removedlist)

removed_wordlist = []
for word in removedlist:
  if word in vocalist:
    removed_wordlist.append(word)     #from removed letter words, finds and adds a vaild English word to a list

longestword = ''
for word in removed_wordlist:
  if (len(word) > len(longestword)):  #from valid English removed words, finds the longest word
    longestword = word

print(longestword)

"""####4/02: Sales Dataset Analysis

>Dataset Analysis
"""

import os
from google.colab import drive
drive.mount("/content/drive")
os.chdir("/content/drive/My Drive/Colab Notebooks")
!ls
#SaaS-Sales.csv -> Sales.csv

#csv module implements classes to read and write tabular data in CSV format.
import csv

#csv.DictReader : create an object that maps the information in each row to a dictionary.
def load_file(file_name):
    data = []
    with open(file_name, 'r') as f:
        content = csv.DictReader(f)
        for row_item in content: #data = [row_item for row_item in content]
          data.append(row_item)
    return data

gen = load_file("Sales.csv")

test = load_file("Testdata.csv")
print(test)

'''
Extract knowledge from the data:
Use functions to analyze data, Don't use pandas or any libraries.
'''

'''
P01. Calculate the Total sales in Specific country
'''

def total_sales(file_data):
  total = 0
  for i in range(len(file_data)):
    if file_data[i]["Country"] == c_name:
      #print every sales element in specific country
      print("Sales: {},".format(file_data[i]["Sales"]), end=' ')
      total += float(file_data[i]["Sales"])
  return total

#user input, function call
c_name = input("Type Country Name: ")
r_sum = total_sales(gen)
#output format
print(f"\nTotal sales of {c_name} is {r_sum}")

'''
P02. Find the Lowest and Highest sales of Different countries
'''

def lowest_sales(file_data):
  min = float("inf")  #used for setting a variable with an infinitely large float value.
  for i in range(len(file_data)):
    if file_data[i]["Country"] == c_name:
      #find the loweset sales value in specific country
      if min > float(file_data[i]["Sales"]):
        min = float(file_data[i]["Sales"])
  return min

#user input, function call
c_name = input("Type Country Name: ")
r_min = lowest_sales(gen)
#output format
print(f"Lowest sales of {c_name} is {r_min}")

def highest_sales(file_data):
  max = 0
  for i in range(len(file_data)):
    if file_data[i]["Country"] == c_name:
      #find the highest sales value in specific country
      if max < float(file_data[i]["Sales"]):
        max = float(file_data[i]["Sales"])
  return max

#user input, function call
c_name = input("Type Country Name: ")
r_max = highest_sales(gen)
#output format
print(f"Highest sales of {c_name} is {r_max}")

'''
P03. Find which Industry has the Highest sales in Specific country
'''

def strongest_industry(file_data, s_max):
  s_industry = str()
  for i in range(len(file_data)):
    if file_data[i]["Country"] == c_name:
      #search the highest sales in a specific country, then find out waht industry it is
      if float(file_data[i]["Sales"]) == s_max:
        s_industry = file_data[i]["Industry"]
  return s_industry

#user input, function call
c_name = input("Type Country Name: ")
s_max = highest_sales(gen)
s_inds = strongest_industry(gen, s_max)
#output format
print(f"In {c_name}, the strongest industry with the highest sales of {s_max} is {s_inds}")

'''
P04. Compare a Specific product in Two cities within a country
to find out which city has the Lowest sales for that product.
'''

def product_lowsale(file_data, ct_name, pr_name):
  min = float("inf")
  for i in range(len(file_data)):
      if file_data[i]["City"] == ct_name and file_data[i]["Product"] == pr_name:
          #find the lowest sales value of specific product in the city
          if min > float(file_data[i]["Sales"]):
            min = float(file_data[i]["Sales"])
  return min

def product_compare(ct_pr_low1, ct_pr_low2, pr_name, ct_name1, ct_name2):
  print(f"The sales of product {pr_name} is ", end='')
  #compare the sales of the same specific product in both cities
  if (ct_pr_low1 < ct_pr_low2):
    print(f"lower in city {ct_name1} than in city {ct_name2}")
  elif (ct_pr_low1 > ct_pr_low2):
    print(f"lower in city {ct_name2} than in city {ct_name1}")
  else:
    print(f"same in both city {ct_name1} and {ct_name2}")

#user input
ct_name1 = input("Type City Name 1: ")
ct_name2 = input("Type City Name 2: ")
pr_name = input("Type Product Name: ")
#function call
ct_pr_low1 = product_lowsale(gen, ct_name1, pr_name)
ct_pr_low2 = product_lowsale(gen, ct_name2, pr_name)
product_compare(ct_pr_low1, ct_pr_low2, pr_name, ct_name1, ct_name2)

'''
P05. Compute the Average profit of Specific country
'''

def avgerage_profit(file_data, c_name, user_opt):
  avg_prof = 0
  cnt = 0
  for i in range(len(file_data)):
    if file_data[i]["Country"] == c_name:
      #check for user options to include loss or not
      if (user_opt == 0):  #do not include loss
        if (float(file_data[i]["Profit"]) < 0):
          continue
        else:
          avg_prof += float(file_data[i]["Profit"])
          cnt += 1
      else:                #include loss
        avg_prof += float(file_data[i]["Profit"])
        cnt += 1
  return avg_prof/cnt

#user input, function call
c_name = input("Enter the name of the country: ")
user_opt = int(input("Do you want to include loss?\nFor yes, type 1. For no, type 0.\n"))
avg_prof = avgerage_profit(gen, c_name, user_opt)
#output format
print("The average profit of {} is {:.3f}".format(c_name, avg_prof))

'''
P06. Create a list of Discount rates with Product names for Specific country,
and print the list in Sorted order or reversed.
'''

def discount_with_product(file_data, c_name):
  disc_list = []
  prod_list = []
  dnp_list = []
  for i in range(len(file_data)):
    #make a list of discounts, and a list of products in specific country
    if file_data[i]["Country"] == c_name:
      disc_list.append(float(file_data[i]["Discount"]))
      prod_list.append(file_data[i]["Product"])
  #zip to make a list of tuple elements containing discount rate and product name
  for i in range(len(disc_list)):
    dnp_list = zip(disc_list, prod_list)
  return set(dnp_list) #to remove duplicates

def user_print_order(c_name, user_opt, dnp_list):
  dnp_list = sorted(dnp_list) #sorts the set and returns list
  #check user option for sorted or reversed order
  if (user_opt == 0):
    user_order = "in sorted order."
  else:
    dnp_list = list(reversed(dnp_list)) #cf. sorted(dnp_list, reverse=True)
    user_order = "in reversed order."
  #print the results in format
  print(f"Discount rates and Product names of {c_name}, {user_order}")
  for i in range(len(dnp_list)):
    print("< {}: {} >".format(dnp_list[i][0], dnp_list[i][1]))

#user input
c_name = input("Enter the name of the country: ")
user_opt = int(input("Do you want to see it in reversed order?\nFor yes, type 1. For no, type 0.\n"))
#function call
dnp_list = discount_with_product(gen, c_name)
user_print_order(c_name, user_opt, dnp_list)

'''
P07. Query a specific Customer ID,
and create a set of Contact names with the Same Customer ID,
then Sort it in alphabetical order and Print it with indexes.
'''

def Group_Contact_Name(file_data, cs_id):
  qr_success = 0
  cn_set = set()
  for i in range(len(file_data)):
    #find the corresponding contact name and add it to set
    if cs_id == int(file_data[i]["Customer ID"]):
      cn_set.add(file_data[i]["Contact Name"])
      qr_success = 1
  #query result ouput format
  if qr_success == 0:
    print("Query Failed: Wrong Customer ID")
  else:
    print("Query Success: Returning Contact Names Group")
  return cn_set

def Print_Contact_Name(cn_set):
  if cn_set != set():
    cn_set = sorted(cn_set)
    #print contact names with indexes
    for idx, name in enumerate(cn_set, start=1):
      print(f"Contact Name {idx:02d}: {name}")
  else:
    print("None")

#user input, function call
cs_id = int(input("Enter the Customer ID: "))
cn_set = Group_Contact_Name(gen, cs_id)
Print_Contact_Name(cn_set)

"""####4/09: Korean String Translator"""

'''
P01.
Write a code to build a simple language translator
that translates text from one language to another,
using string manipulation to substitute words or phrases with their translations.
'''

translations = {
    "hello" : "안녕하세요",
    "world" : "세계",
    "python" : "파이썬"
}

#dictionary.get(keyname, value) : (get the value of given key, value to return if the specified key does not exist)
def func(text):
  translated = ' '.join(translations.get(word, word) for word in text.split())
  return translated

original = "hello world, welcome to python"
print(f"Translated text: {func(original)}")

"""###III. Midterm Project

####III-1. Basic Function
"""

'''
Write a code to build a simple language translator:
Create a translator from korean to english.
Download korean and english dataset.
Word substitute translation may have no meaning.
Basic implement of context translation in sentences.
'''

import os
from google.colab import drive
drive.mount("/content/drive")
os.chdir("/content/drive/My Drive/Colab Notebooks")
#show list of file contents
!ls
#searched kor and eng dataset consists of roughly 200000 sentences each, from book, news, and talk related context,
#changed the excel files into csv format, adjusted to have only one korean, one english matching column.

#csv module to read and write data in CSV format
import csv

#csv.DictReader to map the information in each row to a Dictionary format
def gen_csv(file_name):
    data = []
    #encoding to remove byte order mark
    with open(file_name, 'r', encoding = 'utf-8-sig') as f:
        content = csv.DictReader(f)
        #append each dictionary row as list element
        for dict_row in content:
          data.append(dict_row)
    return data

def data_opt():
  #user input option for data generation from current csv file
  choice = int(input("Do you want to generate data from current csv file?\n1. Yes 2. No:\n"))
  if choice == 1:
    data_kren = gen_csv("kren.csv")
    print("Success: Data Generated from kren.csv!")
  else:
    print("Failure: Data Generation from current csv file- Declined.")
  return data_kren

#generates data dictionary list from csv file
data_kren = data_opt()

print(data_kren[200]) #test sample

#extract from dictionary to create a list of english strings
def string_englist(dict_list):
  data_enst = []
  #get value from specific key
  for row in dict_list:
    data_enst.append(row.get("eng"))
  print("Complete: English String List Generated")
  return data_enst

#extract from dictionary to create a list of korean strings
def string_korlist(dict_list):
  data_krst = []
  #get value from specific key
  for row in dict_list:
    data_krst.append(row.get("kor"))
  print("Complete: Korean String List Generated")
  return data_krst

#list of english string
data_enst = string_englist(data_kren)
#list of korean string
data_krst = string_korlist(data_kren)

print(data_enst[12]) #test sample
print(data_krst[12])

#re module use regular expression to patternize string
import re

def string_to_wordlist(data_st):
  data_wd = []
  for string in data_st:
    #split each string element to list of words, using space delimiter, append it to word list
    word_list = re.split(r"\s", string)
    data_wd.append(word_list)
  return data_wd

#process a list of strings to a list of words
data_enwd = string_to_wordlist(data_enst)
data_krwd = string_to_wordlist(data_krst)

print(data_enwd[16]) #test sample
print(data_krwd[16])

#another method using natural language toolkit, takes more time
import nltk
nltk.download('punkt')

def string_to_wordlist2(data_st):
  data_wd = []
  for string in data_st:
    #tokenize each string element to list of words, extend it to word list
    word_list = nltk.word_tokenize(string)
    data_wd.extend(word_list)
  return data_wd

#process a list of strings to a list of words
data_enwd2 = string_to_wordlist2(data_enst)
data_krwd2 = string_to_wordlist2(data_krst)

print(data_enwd2[3]) #test sample
print(data_krwd2[3])

def usertext_processor(text_data):
  text_wdst = text_data.split()      #split original text to original word list
  return text_wdst

#test input sample: What processors do is buying animals, processing and manufactureing them and then selling beef.
text_data = input("Please input your text data here:\n")
text_wdst = usertext_processor(text_data)

print(text_wdst) #test sample

def eng_to_kor(data_enwd, data_krwd, text_wdst):
  tran_wdst = []
  for word in text_wdst:
    flag = 0
    #search the word in each wordlist, if word is found, save the matching eng-kor wordlists using index
    for idx in range(len(data_enwd)):
      if word in data_enwd[idx]:
        dict_key = data_enwd[idx]
        dict_val = data_krwd[idx]
        flag = 1
        break
    #using the key wordlist, locate translated word in matching value wordlist
    if flag == 1:
      limit = len(dict_val) - 1
      for idx in range(len(dict_key)):
        if word == dict_key[idx]:
          if idx <= limit:
            tran_wdst.append(dict_val[idx])
            break
          else:            #adjust the index range to increase translation match
            tran_wdst.append(word)
    #if there is no matching translated word, put the original word
    else:
      tran_wdst.append(word)
  return tran_wdst

text_rest = eng_to_kor(data_enwd, data_krwd, text_wdst)

print(text_rest) #test sample

def translation_generator(text_rest):
  trans_result = ' '.join(text_rest) #use join to translated wordlist to translated text
  return trans_result

trans_result = translation_generator(text_rest)

print(trans_result) #test sample

def kor_to_eng(data_enwd, data_krwd, text_wdst):
  tran_wdst = []
  for word in text_wdst:
    flag = 0
    #search the word in each wordlist, if word is found, save the matching kor-eng wordlists using index
    for idx in range(len(data_krwd)):
      if word in data_krwd[idx]:
        dict_key = data_krwd[idx]
        dict_val = data_enwd[idx]
        flag = 1
        break
    #using the key wordlist, locate translated word in matching value wordlist
    if flag == 1:
      limit = len(dict_val) - 1
      for idx in range(len(dict_key)):
        if word == dict_key[idx]:
          if idx <= limit:
            tran_wdst.append(dict_val[idx])
            break
          else:            #adjust the index range to increase translation match
            tran_wdst.append(word)
    #if there is no matching translated word, put the original word
    else:
      tran_wdst.append(word)
  return tran_wdst

text_test = usertext_processor("가끔 네가 너무 보고 싶을 때 얼굴만 보여줬으면 좋겠습니다.")  #test sample1

tran_test = kor_to_eng(data_enwd, data_krwd, text_test)

rest_test = translation_generator(tran_test)

print(f"The Korean sentence can be roughly translated like this:\n{rest_test}")

text_test = usertext_processor("가공된 간식은 미국인들에게 위안과 소속감을 의미해요.")       #test sample2

tran_test = kor_to_eng(data_enwd, data_krwd, text_test)
rest_test = translation_generator(tran_test)

print(f"The Korean sentence can be roughly translated like this:\n{rest_test}")

"""####III-2. Added Function"""

#sentence(paragraph) translator
def translator_interface():
  text_dat = input("Please input your text data here:")
  text_wst = usertext_processor(text_dat)     #split original text to original word list

  switch = int(input("Choose One Option\n1. Eng to Kor 2. Kor to Eng translation?\n(Please note that language input should be matched):\n"))
  #Choose option between Eng-Kor and Kor-Eng Translation
  if switch == 1:
    print("You have picked Option 1: Eng to Kor Translation.")
    tran_wst = eng_to_kor(data_enwd, data_krwd, text_wst)
  elif switch == 2:
    print("You have picked Option 2: Kor to Eng Translation.")
    tran_wst = kor_to_eng(data_enwd, data_krwd, text_wst)
  else:
    switch = 0
    print("Translation failed: Wrong Input")

  #display the translated text result to user
  if switch:
    tran_res = translation_generator(tran_wst)
    print(f"The Traslated text result is:\n{tran_res}")

#test sample: English sentence to Korean sentence
translator_interface()
#sample sentence: If it's available, we'd like to place an order for this product.

#test sample: Korean sentence to English sentence
translator_interface()
#sample sentence: 가장 먼 행성인 해왕성은 지구로부터 4.5 킬로미터만큼 떨어져 있을 겁니다.

'''
Random English Sentences:
For example, "a man" will be changed to "a person" and "brothers" will become "brothers and sisters." For this reason, many businesses use pleasant smells to sell their products. By the age of 13, most people have 28 teeth, including two sets of molars. The traffic signal doesn't speak any language, yet everyone understands its meaning. Water pollution is another serious problem, especially for the one billion people living without clean water. But Rattin didn't understand English, so he couldn't understand what the referee was saying. George is the best baseball player on his team. You know, it's a big holiday in Korea. However, in the future, customization - making products exactly according to each buyer's taste - will be very popular. Using your computer, you will be connected directly to the factories that make clothes, cars and other products.
'''

translator_interface() #test sample: basic level English to Korean context translation

'''
Random Korean Sentences:
저는 읽을 책이 많지만, 저는 그것들을 읽을 시간이 없습니다. 한국의 신문에는 새롭고 혁명적인 영어 학습 방법에 대한 광고가 종종 보도된다. 첫째, 인도에서는 매우 많은 사람들이 인터넷에서 사용되는 주요 언어인 영어를 사용한다. 하지만 아주 재미있어요. 어느날 오후, 그녀는 퇴근하면서 사장에게 다름과 같은 쪽지를 남겼다. 의사가 대답했다. “당신은 물을 충분히 마시고 있지 않습니다."
'''

translator_interface() #test sample: basic level Korean to English context translation

#random string translator
def translator_interface():
  import random
  #Choose option between Eng-Kor and Kor-Eng Translation
  switch = int(input("Choose One Option\n1. Eng to Kor 2. Kor to Eng translation?\n(Please note that language input should be matched):\n"))
  if switch == 1:
    print("You have picked Option 1: Eng to Kor Translation.")
    text_dat = random.choice(data_enst) #randomly choose from english string data
    print("Randomly chosen english string:")
    print(text_dat)
    text_wst = usertext_processor(text_dat)     #split original text to original word list
    tran_wst = eng_to_kor(data_enwd, data_krwd, text_wst)
  elif switch == 2:
    print("You have picked Option 2: Kor to Eng Translation.")
    text_dat = random.choice(data_krst) #randomly choose from korean string data
    print("Randomly chosen korean string:")
    print(text_dat)
    text_wst = usertext_processor(text_dat)     #split original text to original word list
    tran_wst = kor_to_eng(data_enwd, data_krwd, text_wst)
  else:
    switch = 0
    print("Translation failed: Wrong Input")

  #display the translated text result to user
  if switch:
    tran_res = translation_generator(tran_wst)
    print(f"The Traslated text result is:\n{tran_res}")

translator_interface() #test sample: Eng to Kor Random Translation

translator_interface() #test sample: Kor to Eng Random Translation

#word translation checker
def translator_interface(word_input):
  text_wst = usertext_processor(word_input)     #split original text(word) to original word list

  switch = int(input("Choose One Option\n1. Eng to Kor 2. Kor to Eng translation?\n(Please note that language input should be matched):\n"))
  #Choose option between Eng-Kor and Kor-Eng Translation
  if switch == 1:
    print("You have picked Option 1: Eng to Kor Translation.")
    tran_wst = eng_to_kor(data_enwd, data_krwd, text_wst)
  elif switch == 2:
    print("You have picked Option 2: Kor to Eng Translation.")
    tran_wst = kor_to_eng(data_enwd, data_krwd, text_wst)
  else:
    switch = 0
    print("Translation failed: Wrong Input")

  #return the translated text(word) result to user
  if switch:
    tran_res = translation_generator(tran_wst)
    return tran_res

def check_translation():
  #ask input for word to translate, and user-translated word
  word_input = input("Please input the word you want to translate: ")
  user_output = input("Please input the translated word: ")
  #get translation output from translator
  tran_output = translator_interface(word_input)
  #check whether the user translation is correct
  if user_output in tran_output:
    print("Translation is correct~:)")
  else:
    print("Translation is wrong~try again:)")

check_translation() #test sample: Eng to Kor Translation Check

check_translation() #test sample: Kor to Eng Translation Check

"""### 8.Classes

####8-1. Defintion of Class

Class: provide a means of bundling data and functionality together.

* Creating a new class creates a new type of object, allowing new instances of that type to be made.

* Each class instance can have attributes attached to it for maintaining its state.

* Class instances can also have methods (defined by its class) for modifying its state.
"""

class class_name:
    class_attribute = value

    def class_method(self, *args):
        self.instance_attribute = value

"""All variables bound to a class are class attributes.

All functions defined within a class are methods.

Conventionally, methods receive the class instance as their first argument, typically named 'self'.
"""

class Point(object): #class: is used to define object
 ''' represents a point in 2d space '''
 x = 0
 y = 0

print(Point)
print(type(Point))

blank = Point() #object is an instance of the class

print(blank)

blank.x = 3.0   #value of class attributes
blank.y = 4.0

print(blank.x)
print(blank.y)
print('%g, %g' %(blank.x, blank.y)) #auto print int or float:locates decimal point

x = 0.0001
y = 10000.0

print('%g, %g' %(x, y)) #detects format
print('%e, %e' %(x, y)) #scientific notation
print('%f, %f' %(x, y)) #print in float

import math

d = math.sqrt(blank.x ** 2 + blank.y **2) #sqrt of 25
d

def print_point(p):
	print('%g, %g' %(p.x, p.y))

print_point(blank) #pass class instance as argument

class Rectangle(object):
 '''represents a rectangle attributes: width, height, corner'''
 width = 0
 height = 0
 corner = 0

box = Rectangle() #create box object: instance of rectangle class

box.width = 100.0 #assign value to class attributes
box.height = 200.0

box.corner = Point() #class attribute corner is Point object
box.corner.x = 0.0
box.corner.y = 0.0

def find_center(rect):
 p = Point() #calculates center using rect object, and stores the result in point object
 p.x = rect.corner.x + rect.width / 2.0
 p.y = rect.corner.y + rect.height / 2.0
 return p

center = find_center(box)
print_point(center)

print(box.width)
print(box.height)

box.width = box.width + 30   #change value of class attributes
box.height = box.height + 10

print(box.width)
print(box.height)

def grow_rectangle(rect, dwidth, dheight):
	rect.width += dwidth
	rect.height += dheight

print(box.width)
print(box.height)

grow_rectangle(box, 3, 2) #use function to change value of class attributes

print(box.width)
print(box.height)

"""####8-2. Copy Module

Copy module: provides generic shallow and deep copy operations

* A shallow copy: constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.

* A deep copy: constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.
"""

import copy #copy object

p1 = Point()
p1.x = 3.0
p1.y = 4.0

p2 = copy.copy(p1)
print_point(p1)
print_point(p2)

print(p1 is p2) #check for equal identity: not same object
print(p1 == p2) #check for equal value: but in object, checks equality based on the reference/instance.

#a basic class for a person
class Person:
 def __init__(self, name, age): #class constructor: automatically called to initialize class instance
  self.name = name
  self.age = age

 def say_hello(self):           #class method: self represents class instance
  print("Hello, my name is", self.name, "and I am", self.age, "years old.")

person1 = Person("Lee", 39) #create Object
print(person1.name)
print(person1.age)

person1.say_hello()

#a basic class for a bank account
class BankAccount:
 def __init__(self, account_number, balance): #class constructor
  self.account_number = account_number
  self.balance = balance

 def deposit(self, amount): #class method
  self.balance += amount
  print("Deposit successful. New balance is:", self.balance)

 def withdraw(self, amount):
  if amount > self.balance: #withdrawal condition
   print("Withdrawal unsuccessful insufficient funds!")
  else:
   self.balance -= amount
   print("Withdrawal successful. New balance is:", self.balance)

account1 = BankAccount("woori1234", 100000)
print(account1.account_number)
print(account1.balance)

account1.deposit(500000)
print(account1.balance)

amount = 20000
account1.withdraw(amount)
print(account1.balance)

class Time():
 '''representing the time of day. attributes: hour, minute, second'''
 hour = 0
 minute = 0
 second = 0

time = Time()
time.hour = 11
time.minute = 43
time.second = 44

print(type(Time))
print(type(time))
print("{:02.0f}:{:02.0f}:{:02.0f}".format(time.hour, time.minute, time.second))

def add_time(t1, t2):
  sum = Time()
  sum.hour = t1.hour + t2.hour
  sum.minute = t1.minute + t2.minute
  sum.second = t1.second + t2.second

  if sum.second >= 60: #basic level time adding
    sum.second -= 60
    sum.minute += 1
  if sum.minute >= 60:
    sum.minute -= 60
    sum.hour += 1

  return sum

time1 = Time()
time1.hour = 9
time1.minute = 45
time1.second = 0

time2 = Time()
time2.hour = 1
time2.minute = 35
time2.second = 0

end = add_time(time1, time2)
print("{:02.0f}:{:02.0f}:{:02.0f}".format(end.hour, end.minute, end.second))

def number_seconds(time): #convert time to second
  number_seconds = time.hour * 3600
  number_seconds += time.minute * 60
  number_seconds += time.second
  return number_seconds

def is_after(t1, t2):     #compare time
  ns1 = number_seconds(t1)
  ns2 = number_seconds(t2)
  return ns1 > ns2

time1 = Time()
time1.hour = 11
time1.minute = 59
time1.second = 1

time2 = Time()
time2.hour = 11
time2.minute = 59
time2.second = 2

is_after(time1, time2) #time1 is not after time2

def increment(time, seconds): #modify time
  time.second += seconds

  if time.second >= 60: #basic level time adding
    time.second -= 60
    time.minute += 1
  if time.minute >= 60:
    time.minute -= 60
    time.hour += 1

time = Time()
time.hour = 1
time.minute = 59
time.second = 30

increment(time, 60)
print("{:02.0f}:{:02.0f}:{:02.0f}".format(time.hour, time.minute, time.second))

def increment(time, seconds):
  #dealing with large seconds
  days = 0
  if seconds >= 86400: #= 24 hours * 60 mins * 60 secs
    days, updated_seconds = divmod(seconds, 86400) #returns days and remaining seconds value
    seconds = updated_seconds
  time.second += seconds                         #increment time.second to the remaining seconds

  if time.second >= 60:
    minutes, seconds = divmod(time.second, 60) #divmod(20, 2) -> 10, 0 <- div// result, mod% result
    time.second = seconds
    time.minute += minutes
  if time.minute >= 60:
    hours, minutes = divmod(time.minute, 60)
    time.minute = minutes
    time.hour += hours
  if time.hour >= 24: #basic level time adding
    days += 1
    time.hour -= 24

  if days > 0:
    print("The number of added seconds is very large")
    print("Some {} days ahead.".format(days))

time = Time()
time.hour = 1
time.minute = 59
time.second = 30

increment(time, 792000)
print("Also In Time: {:02.0f}:{:02.0f}:{:02.0f}".format(time.hour, time.minute, time.second))

def pure_increment(time, seconds): #create new object from input
  days = 0 #deaing with large number of seconds
  if seconds >= 86400:
    days, updated_seconds = divmod(seconds, 86400)
    seconds = updated_seconds

  new_time = Time() #create new object
  new_time.hour = time.hour
  new_time.minute = time.minute
  new_time.second = time.second

  new_time.second += seconds #increment new_time.second by remaining seconds

  if new_time.second >= 60:
    minutes, seconds = divmod(new_time.second, 60)
    new_time.second = seconds
    new_time.minute += minutes
  if new_time.minute >= 60:
    hours, minutes = divmod(new_time.minute, 60)
    new_time.minute = minutes
    new_time.hour += hours
  if new_time.hour >= 24:
    day, hours = divmod(new_time.hour, 24)
    new_time.hour = hours
    days += day

  if days > 0:
    print("the number of seconds is too large")
    print("some {} days ahead".format(days))

  return new_time

time = Time()
time.hour = 1
time.minute = 59
time.second = 30

pure_increment(time, 79500)
print("{:02.0f}:{:02.0f}:{:02.0f}".format(new_time.hour, new_time.minute, new_time.second)) #

"""###9.Inheritance

####9-1. Inheritance and Magic Method

>Inheritance: Being an object-oriented language, Python supports class inheritance. It allows us to create a new class from an existing one.

* The newly created class is known as the subclass (child or derived class).
* The existing class from which the child class inherits is known as the superclass (parent or base class).
"""

# define a superclass
class super_class:
  pass # attributes and method definition

# inheritance
class sub_class(super_class):
  pass
  # attributes and method of super_class
  # attributes and method of sub_class

""">Magic Method: can be used to Overload Operators in User-defined Classes.

* Surrounded by double underscores
* Example: __ __init__ __ , __ __cmp__ __ , __ __add__ __ , __ __str__ __ , etc...

>Operator Overloading:
* When we use an operator on user-defined data types then automatically a special function or magic function associated with that operator is invoked.
* Changing the behavior of operator is as simple as changing the behavior of a method or function.

* *When we use + operator, the magic method __ __add__ __ is automatically invoked in which the operation for + operator is defined. Thereby changing this magic method’s code, we can give extra meaning to the + operator.*
"""

class Card(object):
  '''represents a standard playing card'''
  def __init__(self, suit=0, rank=2): #initial sample: suit = 0 'Clubs', rank = 2 '2'
    self.suit = suit
    self.rank = rank

  suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] #clubs as 0 #diamonds as 1 #hearts as 2 #spades as 3
  rank_names = ['None', 'Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] #jack as 11 #queen as 12 #king as 13

  def __str__(self):        #string
    return '{} of {}'.format(Card.rank_names[self.rank], Card.suit_names[self.suit])

  def __cmp__(self, other): #compare
    if self.suit > other.suit: return 1
    if self.suit < other.suit: return -1

    if self.rank > other.rank: return 1
    if self.rank < other.rank: return -1

    return 0

card1 = Card(2, 11) #Hearts, Jack
print(card1.__str__())

card2 = Card(3, 12) #Spades, Queen
print(card2.__str__())

print(card1.__cmp__(card2)) #card1.suit 11 < card2.suit 12

import random

class Deck(object):
  def __init__(self):
    self.cards = []             #create list type instance_attribute
    for suit in range(4):
      for rank in range(1, 14):
        card = Card(suit, rank) #created object using class Card()
        self.cards.append(card) #add card object to cards list

  def __str__(self):
    res = []
    for card in self.cards:
      res.append(str(card)) #turn card object to string object, append it to list element
    return ', '.join(res)   #join string elements with ', '

  def pop_card(self):
    return self.cards.pop()    #pop card in cards list (pop(): returns last element and deletes it)

  def add_card(self, card):
    self.cards.append(card)    #add card to cards list

  def shuffle(self):
    random.shuffle(self.cards) #shuffle cards list using import random

  def sort(self):   #sort(): is not supported in Card object
    res = []
    for card in self.cards:
      res.append(str(card)) #turn card object to string object, append it to list element
    res.sort()      #sort(): sorts the original list
    return ', '.join(res)

  #card game
  def deal_hands(self, num_hands, num_cards): #destribute (how many hands(peoples), how many cards(for each))
    hands = []
    for i in range(num_hands): #number of hands
      new_hand = Hand() #Hand class is child class of Deck class

      for j in range(num_cards): #number of cards
          card = self.pop_card()  #use pop_card method to remove a card from the deck
          new_hand.cards.append(card) #use append to add a card to the new_hand.cards list

      hands.append(new_hand)   #append new_hand object to list
    return hands

mydeck = Deck()

res = mydeck.__str__()
print(res)

bonus_card = Card()
mydeck.add_card(bonus_card)
print(mydeck) #added '2 of Clubs'

mydeck.pop_card()
print(mydeck) #removed '2 of Clubs'

mydeck.shuffle()
print(mydeck)

res2 = mydeck.sort()
print(res2)

#card game
class Hand(Deck): #Inheritance: Deck is parent, Hand is child class
  '''represents a hand of playing cards'''
  def __init__(self, label=''):
    self.cards = []
    self.label = label #can be used as identifier of hand (not used in below example)

deck = Deck()
deck.shuffle()
game = deck.deal_hands(13, 4) #13 people 4 cards each

for index, hand in enumerate(game): #game returns hands object
  print("Hand {}: {}\n".format(index + 1, hand)) #index starts from 1

"""###10.Pandas

####10-1. Pandas Library

Pandas: Pandas is a software library written for the Python programming language for data manipulation and analysis.
"""

pip install pandas #Pip Installs Packages

pip freeze #outputs installed packages

import pandas as pd #imports installed package

"""####10-2. Data Structures

DataFrame
>2-dimensional data structure, data is aligned in a tabular fashion in rows and columns.
"""

data = {'Name' : ['Lee', 'Park', 'Choi'],
        'Age' : [21, 22, 21],
        'City' : ['Seoul', 'Busan', 'Incheon']}

ds1 = pd.DataFrame(data)

display(ds1)

"""Series
>1-dimensional labeled array and capable of holding data of any type (integer, string, float, python objects, etc.)
"""

ds2 = pd.Series([1, 2, 3, 4, 8])

display(ds2)

"""####10-3. Data Viewing: CSV File"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks')
!ls

df1 = pd.read_csv('Testdata.csv')

print(df1.head()) #show top 5 rows

print(df1.tail()) #show bottom 5 rows

df1.info() #show info: index, dtype, columns, non-null values, memory usage.

"""DataFrame method: describe()
>For object data (e.g. strings or timestamps), the result’s index will include count, unique, top, and freq.
* The count is the number of data.
* The unique is the number of unique value.
* The top is the most common value.
* The freq is the most common value’s frequency.
"""

df1.describe() #method(): summary statistics for numerical columns

df1.shape #return a tuple representing the dimensionality of DataFrame

df1.columns #attribute: show column labels of DataFrame

tmp_df = df1.drop_duplicates() #return DataFrame with duplicate rows removed

tmp_df.shape #if there was duplicates, now no duplicates

"""####10-4. Data Viewing: JSON File

JSON: JavaScript Object Notation, JSON is a text format for storing and transporting data.
"""

df2 = pd.read_json('iris.json')

df2

df2.shape

df2.info()

"""DataFrame Method: describe()
>For numeric data, the result’s index will include count, mean, std (standard deviation), min, max as well as lower, 50 and upper percentiles.

>By default the lower percentile is 25 and the upper percentile is 75. The 50 percentile is the same as the median.
"""

df2.describe()

"""####10-5. Extract and Filter Data"""

petal_lens = df2['petalLength'] #extracting data, in specific column

petal_lens

petal_lens_wids = df2[['petalLength', 'petalWidth']] #extracting data, in multiple specific columns

petal_lens_wids

#filter: subset the dataframe rows according to the specified index labels. (specific column, specific value)
petal_len = df2[df2['petalLength'] == 1.4]

petal_len

#integer-location based indexing for selection by position (row 0,1,2,3, col 1,2,3 slice)
subset1 = df2.iloc[0:4, 1:4]
subset1

"""####10-6. Sort and Group Data"""

sorted_df = df2.sort_values('petalLength') #sort by the values along specific column

sorted_df

#group by (column), mean of [column]: compute mean of each groups, excluding missing values.
grouped_df = df2.groupby('species')['petalLength'].mean()

print(grouped_df)

"""####10-7. Change and Check Data"""

#apply() a function along an axis of the DataFrame
df2['petalWidth'] = df2['petalWidth'].apply(lambda x: x+1) #increase values of specific column using lambda function

df2 #petalWidths has been increased by 1

df2.shape

#drop null values: remove missing values. NaN: not a number.
df2 = df2.dropna()

df2.shape #there was no null values in df2, nothing changed

#check for null values: detect missing values.
df2.isnull()

""">Appending New Row to Dataframe"""

#concatenate pandas objects along a particular axis
new_row = {'sepalLength' : 8.1}
#other columns values will be NaN
df2 = pd.concat([df2, pd.DataFrame([new_row])], ignore_index = True)
#ignore_index: If True, do not use the index values along the concatenation axis. The resulting axis will be just labeled 0, ..., n - 1.

df2 #new row added at bottom

df2.isnull() #check for null values

df2.shape

df2 = df2.dropna() #new row will be removed, since it's containing null values

df2.shape #new added row has been removed

df2.isnull().sum() #no null values in each column, so sum of null values is 0, in each column

df2.isnull().sum() #when added new row with null values in some columns

#Fill Null/NaN values using the specified method: null values in column[petalLength] will be filled with 0, instead of nan
df2['petalLength'] = df2['petalLength'].fillna(0)

df2.isnull().sum() #petalLength no longer has null values

#replace values given in to_replace, with value
df2['species'] = df2['species'].replace('setosa', 'st')

df2 #setosa has been changed to st

"""####10-8. Data Visualization

Matplotlib: is a comprehensive library for creating static, animated, and interactive visualizations in Python.
>matplotlib.pyplot is a collection of functions that make matplotlib work like MATLAB.
"""

import matplotlib.pyplot as plt
#draw histogram regarding specific column in DataFrame
df2['petalLength'].plot(kind='hist')
plt.show()

plt.plot(df2['petalLength']) #for specific column, plot y versus x as lines.

"""####10-9. Change Data: Add Column

>Appending New Column to Dataframe
"""

target_column = 'petalLength'
#get_loc (get integer location) in columns
target_column_index = df2.columns.get_loc(target_column)
print(target_column_index)

new_column_name = 'Quality'

#tolist() returns a list of the values, in this case columns list
cols = df2.columns.tolist()

#insert column name into DataFrame (columns list) at specified location.
cols.insert(target_column_index + 1, new_column_name)

#form DataFrame in new index with optional filling logic; columns = new labels for the columns.
df2 = df2.reindex(columns = cols)

df2 #new column 'quality' has been added after 'petalLength'

#add values to newly added column 'Quality' using apply() with lambda function
df2['Quality'] = df2['petalLength'].apply(lambda x: 'High' if x >= 5 else 'Basic') #condition regarding 'petalLength' value

df2

"""###11.SciPy

####11-1. SciPy Library
"""

'''
Scientific Python Library:
While NumPy focuses on array manipulation and basic linear algebra,
SciPy offers a broader spectrum of scientific tools, algorithms,
and functions for a wide range of domains,
including optimization, signal processing, statistics, etc.
'''

!pip install scipy

import scipy
print(scipy.__version__)

"""####11-2. SciPy Constants"""

from scipy import constants

constants.pi

print(dir(constants)) #show constants in list

from tabulate import tabulate #pretty-print tabular data in Python, a library and a command-line utility.

constants_names = dir(constants)

constants_names = [name for name in constants_names if isinstance(getattr(constants, name), (int, float))]
# getattr(object, 'name')  # isinstance(object, type) returns True or False

table = [[name, getattr(constants, name)] for name in constants_names]

headers = ["names", "constants"]
table_str = tabulate(table, headers, tablefmt = 'pipe') #tablefmt: table print format
print(table_str)

constants.gram

constants.pound

constants.minute

constants.hour

constants.year

constants.inch

constants.atm #atmosphere

constants.hectare

constants.liter

constants.kmh

constants.zero_Celsius

constants.calorie

"""####11-3. Optimization"""

import math
from scipy.optimize import root
#SciPy optimize provides functions for minimizing (or maximizing) objective functions

def f1(x):
  return x + math.cos(x)

r = root(f1, 0) #use root(func, initial guess value) to find root value
print(r.x)      #print solution array
#The root function will provide an approximation of the value of x that satisfies the func equation

"""####11-4. Gradient Descent"""

from scipy import misc #miscellaneous utilities
import matplotlib.pyplot as plt
import numpy as np

def f2(x):
  return 4 * (x ** 3) - (10 * x) - 3

x = np.arange(-2.0, 2.0, 0.01)
#arange(start, stop, step) values are generated within the interval [start, stop)

y = f2(x)

plt.plot(x, y, 'y-') #'y-' : yellow solid line
plt.xlim(-7, 7)      #set axis limits
plt.ylim(-11, 11)

# Graph Plot print format
plt.plot(x, y, 'y-')
plt.xlim(-7, 7)
plt.ylim(-11, 11)

# Gradient descent parameters
learning_rate = 0.005 #next step
iterations = 100
start = 2.0

# Evaluate the function at the starting point
y0 = f2(start)
y1 = y0

# Graph Plot print the initial point: A dot of y vs. x
plt.scatter(start, f2(start), color='r', marker='^', s=150) #size

# Gradient descent
i = 200.0
while i > 0.0001 and iterations > 0: #stop condition
  start = start - learning_rate * misc.derivative(f2, start) #update start
  y0 = f2(start)
  y1 = y0
  i = abs(y1 - y0) #track the change in function value between iterations (stops iterating when change becomes very small)
  iterations = iterations - 1 #-1 iteration
  plt.scatter(start, y0, marker='^', s=50) #print new dot

print('A minimum point was found as:', start, y0) #local minimum
plt.grid()
plt.show #show final plot

"""####11-5. Sparse Data"""

[1, 0, 2, 0, 0, 3, 0] #sparse data example
#sparse data: most of item values are zero <> dense data: most of item values are non-zero

from scipy.sparse import csr_matrix #Compressed Sparse Row matrix

arr = np.array([0, 0, 0, 0, 0, 1, 1, 0, 2])

print(csr_matrix(arr)) #location of non-values (row, col)

print(csr_matrix(arr).data) #non-zero data values

print(csr_matrix(arr).count_nonzero()) #number of non zero values

mat = csr_matrix(arr)

mat.eliminate_zeros() #removes zero values

print(mat)

from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import connected_components #Analyze the connected components of a sparse graph

adjacency_matrix = csr_matrix([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]])
'''
Node 0 is connected to node 1.
Node 1 is connected to nodes 0 and 2.
Node 2 is connected to node 1.
Node 3 is isolated (not connected to any other node).
'''
num_components, labels = connected_components(adjacency_matrix)

print("Number of connected components:", num_components)
print("Labels of components for each node:", labels)

#Nodes 0, 1, and 2 are part of the same connected component (labeled 0).
#Node 3 is part of a different connected component (labeled 1).

for component in range(num_components):
  component_nodes = [node for node, label in enumerate(labels) if label == component] #creates a list per label
  print('Connected component', component_nodes)
#node 3 is not connected with 0, 1, 2

"""####11-6. Graph and Tree"""

'''Graph consists of vertice(node), and edge:
directive graph vs indirective graph: Undirected graphs have edges that do not have a direction'''

#simple way to define a graph using dictionary
graph = {
    '5' : ['3', '7'],
    '3' : ['2', '4'],
    '7' : ['8']
}

import networkx as nx
#Package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.

class GraphVisualization: #creating graph visualization class, using nx
  def __init__(self):
    self.visual = [] #empty list
  def addEdge(self, a, b):
    temp = [a, b]
    self.visual.append(temp) #describe edge in list format
  def visualize(self):
    G = nx.Graph() #Create an empty graph with no nodes and no edges.
    G.add_edges_from(self.visual) #add edge
    nx.draw_networkx(G) #visualize Graph
    plt.show()

""">1) Indirective Graph"""

#indirective graph
G1 = GraphVisualization() #create class object
G1.addEdge('u', 'v')
G1.addEdge('v', 'w')
G1.addEdge('w', 'u')
G1.visualize()

""">2) Weighted Graph"""

#weighted graph
G2 = nx.Graph()
i = 1
G2.add_node(i, pos=(i, i)) #add node
G2.add_node(2, pos=(2, 1))
G2.add_node(3, pos=(1, 0))

G2.add_edge(1, 2, weight=5) #add edge with weights
G2.add_edge(1, 3, weight=4)
G2.add_edge(2, 3, weight=3)

pos = nx.get_node_attributes(G2, 'pos')
nx.draw(G2, pos) #draw nodes

labels = nx.get_edge_attributes(G2, 'weight')
nx.draw_networkx_edge_labels(G2, pos, edge_labels=labels) #draw labels (weights)

nx.is_connected(G2) #checks for whether graph is connected

""">3) Directive Graph"""

#directive graph
G3 = nx.DiGraph() #create directive graph
G3.add_edges_from([('u', 'u'), ('u', 'v'), ('v', 'w'), ('w', 'u')]) #loop is formed in u to u
nx.draw_networkx(G3)

""">4) Shortest Path"""

#shortest path
G4 = nx.DiGraph()
G4.add_edges_from([('a', 'b'), ('b', 'd'), ('b', 'f'),
 ('b', 'g'), ('b', 'c'), ('c', 'g'),
  ('g', 'e'), ('d', 'f'), ('d', 'h'), ('g', 'h')])
nx.draw_networkx(G4)

nx.dijkstra_path(G4, 'a', 'h') #shortest path (start, end)

G5 = nx.DiGraph()
G5.add_edge('a', 'b', length=7) #add edge with length
G5.add_edge('b', 'd', length=9)
G5.add_edge('b', 'f', length=5)
G5.add_edge('b', 'g', length=8)
G5.add_edge('b', 'c', length=7)
G5.add_edge('c', 'g', length=6)
G5.add_edge('g', 'e', length=9)
G5.add_edge('d', 'f', length=7)
G5.add_edge('d', 'h', length=9)
G5.add_edge('g', 'h', length=3)

'''
spring_layout: simulates a force-directed representation of the network
treating edges as springs holding nodes close,
while treating nodes as repelling objects
'''
pos = nx.spring_layout(G5)
nx.draw_networkx(G5, pos, with_labels=True, connectionstyle='arc3, rad=0.2')
#connectionstyle: arc form, rad curvature

nx.dijkstra_path(G5, 'a', 'h') #shortest path

""">5) Tree"""

'''Tree'''
from networkx.drawing.nx_pydot import graphviz_layout #Create node positions using Pydot and Graphviz.
T1 = nx.Graph()
T1.add_edges_from([(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (4, 8)])

pos = graphviz_layout(T1, prog='dot') #node positions
nx.draw(T1, pos, with_labels=True)

nx.is_tree(T1) #check whether graph is tree

"""###12.MatplotLib

####12-1. Subplot

>Matplotlib: Comprehensive library for creating static, animated, and interactive visualizations.
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

#IPython extension to show result immediately.
#IPython extension to reload modules before executing user code.
# %matplotlib inline
# %reload_ext autoreload
# %autoreload 2

x = np.linspace(-5, 5, 100)
y = np.sin(x)

plt.xlabel('x')
plt.ylabel('y')
plt.title('Sine(x)')

plt.plot(x, y)
plt.show()

z = np.cos(x)

""">Figure: The top level container for all the plot elements.
* fig, ax = plt.subplots() : show multiple graphs at once
* figure : total subplots
* axe: each subplot
"""

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5)) #Create a figure and a set of subplots. (nrows, ncols, )

ax1.plot(x, y, color='blue', label='Sine(x)')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('Sine(x)')

ax2.plot(x, z, color='red', label='Cosine(x)')
ax2.set_xlabel('x')
ax2.set_ylabel('z')
ax2.set_title('Cosine(x)')

plt.tight_layout() #Adjust the padding between and around subplots.

""">Axes: Encapsulates all the elements of an individual (sub)plot in a figure. It contains most of the (sub)plot elements: Axis, Tick, Line2D, Text, Polygon, etc., and sets the coordinate system."""

x_1 = np.linspace(0, 5, 10)
y_1 = x_1 ** 2

fig_1 = plt.figure(figsize=(5, 4), dpi=100) #dpi resolution of the figure
axes_1 = fig_1.add_axes([0.1, 0.1, 0.9, 0.9]) #add axes: rectangle

axes_1.set_xlabel('Days')
axes_1.set_ylabel('Days squared')
axes_1.set_title('Days squared chart')

axes_1.plot(x_1, y_1, label = 'x / x^2')
axes_1.plot(y_1, x_1, label = 'x^2 / x')

axes_1.legend(loc = 0) #bestfit

axes_2 = fig_1.add_axes([0.45, 0.45, 0.4, 0.3])
axes_2.text(0.4, 0.4, 'Something') #Add text to the Axes. Add the text string to the Axes at location x, y in data coordinates.

x = np.linspace(-5, 5, 100)
y1 = np.sin(x)
y2 = np.cos(x)

flg, axes = plt.subplots(1, 2, figsize=(10, 5)) #row = 1, col = 2 : 1D

axes[0].plot(x, y1, color='blue')
axes[1].plot(x, y2, color='red')

axes[0].text(0.5, -0.2, 'a) Sine(x)', transform=axes[0].transAxes, ha='center', fontsize=10, fontweight='bold')
axes[1].text(0.5, -0.2, 'b) Cosine(x)', transform=axes[1].transAxes, ha='center', fontsize=10, fontweight='bold')
#transformation framework to easily move between coordinate systems

flg.suptitle('Plots of sine and cosine functions', fontsize= 12, fontweight= 'bold')
plt.tight_layout()

def random_plots():
  xs = []
  ys = []
  for i in range(20):
    x = i
    y = np.random.randint(10)
    #return random integers from low (inclusive) to high (exclusive).
    xs.append(x)
    ys.append(y)
  return xs, ys

fig = plt.figure()

#make four subplots: Create a subplot at a specific location inside a regular grid.
ax1 = plt.subplot2grid((5, 2), (0, 0), rowspan=1, colspan=2) #shape, loc
ax2 = plt.subplot2grid((5, 2), (1, 0), rowspan=3, colspan=2)
ax3 = plt.subplot2grid((5, 2), (4, 0), rowspan=1, colspan=1)
ax4 = plt.subplot2grid((5, 2), (4, 1), rowspan=1, colspan=1)

x, y = random_plots()
ax1.plot(x, y)

x, y = random_plots()
ax2.plot(x, y)

x, y = random_plots()
ax3.plot(x, y)

x, y = random_plots()
ax4.plot(x, y)

plt.tight_layout()

"""####12-2. Beautify Plot"""

#b: blue, g: green, r: red, c: cyan, m: magenta, y: yellow, k: black, w: white
#percentage: color="0.75"
#hexcode: "#eeefff"

fig_3 = plt.figure(figsize=(6,4))
axes_3 = fig_3.add_axes([0, 0, 1, 1])

axes_3.plot(x_1, y_1, color='navy', alpha=0.75, lw= 2, ls= '-.', #Transparency level. /Sets the line width to 2. /Sets the line style to dash-dot.
            marker= 'o', markersize= 7, markerfacecolor= 'y', markeredgecolor= 'b', markeredgewidth= 4)

axes_3.set_xlim([0, 3]) #restricts the x-axis to the range between 0 and 3.
axes_3.set_ylim([0, 8])

axes_3.grid(True, color= '0.6', dashes=(5, 2, 1, 2)) #Sets a custom dash pattern for the grid lines. points dash, points gap.
axes_3.set_facecolor('#FAEBD7') #background color

#available formats: png, pdf, ps, eps, svg, pgf
fig_3.savefig('my_plot') #save plots

#Creating Explanation Tags
fig_4 = plt.figure(figsize=(5, 4), dpi =100)
axes_4 = fig_4.add_axes([0., 0.1, 0.9, 0.9])

axes_4.text(0, 18, r'$\alpha \beta \sigma \omega \epsilon \mu \pi \theta \lambda$', fontsize=20)
axes_4.text(0, 13, r'$\delta_i \theta^j \geq \leq \ne$', fontsize=20) #subscipt, superscript, comparison
axes_4.text(0, 22, r'$\sum_{i=0}^\infty x_i$', fontsize=20) #$ ignores \

axes_4.plot(x_1, y_1)

#read csv file using pandas
import os
from google.colab import drive
drive.mount('/content/drive')
os.chdir('/content/drive/My Drive/Colab Notebooks')

df = pd.read_csv('students.csv')
print(df.head())

#create bar chart style plot from pandas dataframe
plt.bar(df['name'], df['physics'], label='Physics score')
plt.bar(df['name'], df['maths'], label='Maths score')

plt.xlabel('Student Name')
plt.ylabel('Physics and Maths')
plt.title('Physics vs. Maths')

plt.legend()

data = {
    'category' : ['A', 'B', 'C', 'D', 'E'],
    'values' : [10, 20, 15, 25, 12]
}
df = pd.DataFrame(data)

#create pie chart style plot from pandas dataframe
plt.pie(df['values'], labels=df['category'], autopct='%1.1f%%')
#autocpt: formats the percentages displayed on each slice of the pie chart to one decimal place.1f, prints %.

plt.title('Pie Chart')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
#place the category box at the coordinates of x, y based on the figure box. and locate it at upper left.

label= 'A', 'B', 'C', 'D', 'E'
sizes= [10, 20, 15, 25, 12]

fig, ax = plt.subplots()
ax.pie(sizes, labels=label, hatch=['**O', 'oO', 'o.o', '.||.']) #create patterns

#offsetting a slice using explode
explode_one = (0, 0.2, 0, 0, 0)
fig, ax = plt.subplots()

ax.pie(sizes, explode= explode_one, labels= label, autopct= '%1.1f%%', shadow= True, startangle= 90) #Start Angle to Rotate Pie

"""####12-3. 3D Plot"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

#table (formatting) using tabulate
from tabulate import tabulate

data = [['Name', 'Age', 'Bender'],['Lee', 20, 'M'],['Park', 10, 'M'],['Youjin', 19, 'F']]

table = tabulate(data, headers= 'firstrow', tablefmt= 'grid')
print(table)

#table (formatting & coloring) using matplotlib
fig, ax = plt.subplots()
ax.axis('off')
table = ax.table(cellText= data, cellLoc= 'center', loc= 'center', cellColours= [['lightgray']*3]+[['white']*3]*3, bbox= [0,0,1,1])
#bbox /0, 0 the lower-left corner /1, 1 the upper-right corner of the axes : table fill the entire area of the axes

table.auto_set_font_size(False)
table.set_fontsize(12)
table.scale(1, 1.5)

#scatter plot
x1 = [2, 3, 4]
y1 = [5, 5, 5]

x2 = [1, 2, 3, 4, 5]
y2 = [2, 3, 2, 3, 4]
y3 = [6, 8, 7, 8, 7]

plt.scatter(x1, y1)
plt.scatter(x2, y2, marker= 'v', color= 'red')
plt.scatter(x2, y3, marker= '^', color= 'm')

#3d scatter plot
fig = plt.figure()
ax = fig.add_subplot(111, projection = '3d') #create 3d plot space

x1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y1 = np.random.randint(10, size= 10)
z1 = np.random.randint(10, size= 10)

x2 = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]
y2 = np.random.randint(10, size= 10)
z2 = np.random.randint(10, size= 10)

ax.scatter(x1, y1, z1, c= 'b', marker= 'o', label= 'blue') #create 2d scatter plot
ax.scatter(x2, y2, z2, c= 'g', marker= 'D', label= 'green')

ax.set_xlabel('x axis')
ax.set_ylabel('y axis')
ax.set_zlabel('z axis')

plt.title('3D scatter plot')
plt.legend()
plt.tight_layout() #adjust the padding between and around subplots.

#3d bar plot
fig = plt.figure()

ax = fig.add_subplot(111, projection = '3d') #Create 3d plot space

x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
y = np.random.randint(10, size= 10)
z = np.zeros(10)

dx = np.ones(10)
dy = np.ones(10)
dz = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

ax.bar3d(x, y, z, dx, dy, dz, color= 'g') #Create 3d bar plot

plt.tight_layout()

#3d with contour plot
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)

X, Y = np.meshgrid(x, y) #Return a list of coordinate matrices from coordinate vectors.
Z = np.sin(np.sqrt(X**2 + Y**2))

fig = plt.figure(figsize= (10, 5))

ax_surface = fig.add_subplot(121, projection= '3d') #3D surface plot
ax_surface.plot_surface(X, Y, Z, cmap= 'viridis')

ax_contour = fig.add_subplot(122) #nrows, ncols, pltnum : means plt is placed at 1d array second col place
contour_plot = ax_contour.contour(X, Y, Z, cmap= 'viridis') #contour plot

plt.subplots_adjust(wspace= 0.3) #Increases the horizontal space between the two subplots

"""###13.MitoSheet"""

#can be used at jupyter environment

"""###.idx"""



"""###IV. Practices 2

####5/07: Class and Inheritance

Q1. Write a code for a class that represents a rectangle with attribute length and width.

It has methods to calculate the area and perimeter of the rectangle.
"""

class Rect:
  def __init__(self, width, height):
    self.width = width
    self.height = height

  def area(self):
    return self.height * self.width

  def perimeter(self):
    return (self.height + self.width) * 2

box = Rect(15, 14) #create Rect object and initialize object
print("The area of rectangle is:", box.area())
print("The perimeter of rectangle is:", box.perimeter())

"""Q2. Write a base class Person with attributes name and age, along with a method display_info() to display the person's information.

The subclasses Student and Teacher inherit from Person, and add additional attributes student_id and subject, respectively.

Each subclass also overrides the display_info() method to include its specific attributes.

Finally, create instances of Person, Student, and Teacher classes to demonstrate inheritance and method overriding.
"""

class Person(object): #Super Class
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def display_info(self):
    return f'Name: {self.name}, Age: {self.age}'

class Student(Person): #Sub Class1
  def __init__(self, name, age, id):
    super().__init__(name, age) #Class Inheritance from super class __init__
    self.id = id
  def display_info(self):
    return f'Name: {self.name}, Age: {self.age}, Id: {self.id}'

class Teacher(Person): #Sub Class2
  def __init__(self, name, age, subject):
    super().__init__(name, age) #Class Inheritance from super class __init__
    self.subject = subject
  def display_info(self):
    return f'Name: {self.name}, Age: {self.age}, Subject: {self.subject}'

p1 = Person('Kim', '25')
p2 = Student('Park', '26', '2001216')
p3 = Teacher('Lee', '27', 'CS')

print(p1.display_info())
print(p2.display_info())
print(p3.display_info())

"""Q3. Bank Account Class with Balance, Deposit, Withdraw, Interest, Save File methods."""

from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks/Testy')

import csv

class Account():
 def __init__(self, account_num, balance):
  self.account_num = account_num
  self.balance = balance

 def balanace(self, amount):
  return f'Balance is: {self.balance}'

 def deposit(self, amount):
  self.balance += amount
  print("Deposit successful. New is:", self.balance)

 def withdraw(self, amount):
  if amount > self.balance:
   print("Withdrawal Not successful!")
  else:
   self.balance -= amount
   print("Withdrawal successful. New is:", self.balance)

 def interest(self, rate):
  self.balance = self.balance + self.balance * rate
  print("Interest rate applied. New is:", self.balance)

 def save(self):
  data = [['Numb', 'Amount'], [self.account_num, self.balance]]
  with open('data.csv', 'w', newline = '') as file:
    wr = csv.writer(file) #use csv.writer
    wr.writerows(data)    #to write rows in csv file

account1 = Account('woori', 20000)
print(account1.balance)

account1.withdraw(2000)

account1.save()

account1.deposit(2000)

account1.save()

account1.interest(0.3)

account1.save()

"""Q4. Write a class to demonstrate Operator overloading for Complex numbers.

Complex Number consists of Real + Imag Part: a + bi.

Use Operator Overloading for Complex number Calculations.
"""

class CalcComplex:
  def __init__(self, real, imag):
    self.real = real
    self.imag = imag

  def __add__(self, other):
    real_part = self.real + other.real
    imag_part = self.imag + other.imag
    return CalcComplex(real_part, imag_part)

  def __sub__(self, other):
    real_part = self.real - other.real
    imag_part = self.imag - other.imag
    return CalcComplex(real_part, imag_part)

  def __mul__(self, other):
    real_part = self.real * other.real - self.imag * other.imag
    imag_part = self.real * other.imag + self.imag * other.real
    return CalcComplex(real_part, imag_part)

  def __str__(self):
    return f'{self.real} + {self.imag}i'

op1 = CalcComplex(2, 3)
op2 = CalcComplex(4, 5)

#using operator overload for complex number calculation
print("Addition:", op1 + op2)
print("Subtraction:", op1 - op2)
print("Multiplication:", op1 * op2)

"""####5/14: Pandas Library

>1) Install and Display CSV File
"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir('/content/drive/My Drive/Colab Notebooks')
!ls

#alternative way to download file from other google drive
import gdown
url = 'https://drive.google.com/uc?id=1z9IM_9JdKRpLTaEvf3Q3-sBpY1fjrKc0'
gdown.download(url, 'healthcare_dataset.csv', quiet=False)

import pandas as pd

df = pd.read_csv('healthcare_dataset.csv')

df

df.info()

df.head()

df.tail()

df.describe()

""">2) Data Manipulation

>Filtering Data
"""

ages = df['Age']
ages

df.iloc[0]

older_than_30 = df[df['Age'] > 30]
older_than_30

is_fem = df[df['Gender'] == 'Female']
is_fem

""">Dealing with Null Data"""

df_cleaned = df.dropna()
df_cleaned #already cleaned data, thus no change

df_filled = df.fillna(value='NA')
df_filled #fill null value with 'NA'

df['Medication'].fillna('Not specified', inplace=True) #inplace: If True, fill in-place. (inplace: not recommend in using)
df

""">Chaging Columns"""

df_rename = df.rename(columns={'Medical Condition': 'Medical Condition', 'Date of Admission': 'Date of Admission'})
df_rename #renaming columns

df['Admission Type'] = df['Admission Type'].replace({'Emergency':'Urgent', 'Scheduled':'Planned'})
df['Admission Type'] #replace column names

df['Age'] = df['Age'].apply(lambda x: x+1)
df['Age'] #change values of specific column

target_column_index = df.columns.get_loc('Age')
print(target_column_index) #locate column index

cols = df.columns.tolist()
cols.insert(target_column_index + 1, 'International')  #adding new column
df = df.reindex(columns = cols)

df['International'] = df['Age'].apply(lambda x: x+ 1) #add values to the new column

df

target_column_index = df.columns.get_loc('International')
print(target_column_index) #get column index

cols = df.columns.tolist()
cols.insert(target_column_index + 1, 'International') #add new column
df = df.reindex(columns = cols)

df['Age Group'] = df['Age'].apply(lambda x: 'Kid' if x <= 10 else 'Old') #give values to newly added column
df['Age Group']

df_dropped = df.drop(columns=['Doctor', 'Insurance Provider'])
df_dropped #drop columns

""">3) Aggregate Function

>Pivot Table
"""

pivot = pd.pivot_table(df, values = 'Billing Amount', index='Gender', columns = 'Blood Type', aggfunc = 'mean') #aggfunc: aggregate function that pivot_table applies to your data
pivot #create a spreadsheet-style pivot table as a DataFrame.

pivot2 = pd.pivot_table(df, values = 'Billing Amount', index='Gender', columns = 'Blood Type', aggfunc = 'count')
pivot2

""">Grouping"""

grouped = df.groupby('Gender')['Age'].mean() #group by specific column
grouped

per_total = df.groupby('Name')['Billing Amount'].sum()
per_total

per_mean = df.groupby(['Gender', 'Admission Type'])['Billing Amount'].mean()
per_mean

""">Cross Table"""

crosstab_result = pd.crosstab(df['Gender'], df['Blood Type'])
crosstab_result #compute a simple cross tabulation of two (or more) factors.

""">4) Matplotlib Library"""

import matplotlib.pyplot as plt
df['Age'].hist()
plt.show()

df.boxplot(column='Billing Amount', by='Gender')
plt.show()

""">5) Datetime Converting"""

df['Date of Admission'] = pd.to_datetime(df['Date of Admission'])
df['Date of Admission'] #converting to datetime

df_year = df['Date of Admission'].dt.year
df_year #extracting year in datetime

df_mon = df['Date of Admission'].dt.month #dt.day
df_mon

""">6) Indexing and Sorting"""

df_sorted = df.sort_values(by=['Age', 'Billing Amount'], ascending=[True, False])
df_sorted #age in asecend, billing in descend order

df_reset_index = df.reset_index(drop=True)
df_reset_index #reset index to original order

""">7) Seaborn Library"""

#statistical data visualization, high level than matplotlib
import seaborn as sns
sns.pairplot(df[['Age', 'Billing Amount', 'Room Number']])
plt.show() #plot pairwise relationships in a dataset.

sns.barplot(x='Admission Type', y='Billing Amount', data=df)
plt.show() #barplot plots the mean of a variable by category

sns.countplot(data=df, x='Blood Type')
plt.show() #countplot plots the count of the number of records by category

sns.histplot(data=df, x='Age', kde=True)
plt.show() #kde = kernel density estimate, shows more smoother plot than hist

sns.boxplot(data=df, x='Gender', y='Billing Amount')
plt.show() #draw a box plot to show distributions with respect to categories.

sns.violinplot(data=df, x='Gender', y='Age')
plt.show() #draw a patch representing a KDE and add observations or box plot statistic

"""####5/21: SciPy Library

>1) ndimage:	N-dimensional image processing
"""

import os
from google.colab import drive
drive.mount('/content/drive')
os.chdir('/content/drive/My Drive/Colab Notebooks')
!ls

from scipy import ndimage
import matplotlib.pyplot as plt
from PIL import Image #for processing image file, Python Imaging Library

import cv2 #Open Computer Vision Library

image_path = 'img.png'
image = cv2.imread(image_path)

image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) #convert bgr to rgb

plt.imshow(image_rgb)
plt.axis('off')
plt.show()

gray_img = np.mean(image, axis=2)
#Compute the arithmetic mean along the specified axis.
plt.imshow(gray_img, cmap='gray') #choose color map

from scipy import misc
import matplotlib.pyplot as plt

face = misc.face() #test image in scipy
plt.imshow(face)
plt.axis('off')

""">2) signal: Signal Processing - Local Minimum Computing"""

#find local minimum for y = x^2 + 2x + 5
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def func(x):
   return x ** 2 + 2 * x + 5

x = np.linspace(-10, 10, 1000) #evenly spaced numbers over a specified interval
y = func(x)

peaks, _ = find_peaks(-y) #don't need , properties
#find peaks inside a signal based on peak properties, in this case -y

plt.plot(x, y, label='x^2 + 2x + 5')
plt.scatter(x[peaks], y[peaks], color='r', marker='x', label='local minima')
#print local minima as dot

plt.xlabel('x')
plt.ylabel('y')
plt.title('Fuction and Local Minima')

plt.legend() #범례
plt.grid(True)

""">3) linalg: Linear Algebra

* Matrix
"""

import numpy as np
from scipy import linalg
#linear algebra is the branch of mathematics concerning linear equations

#find sum, determinent, inverse, eigen value of matrix
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
C = A + B
C

#행렬식
det_A = linalg.det(A)
det_A

#역행렬
A_inv = linalg.inv(A)
A_inv

#고유값
linalg.eig(A)

"""* Simultaneous equation"""

#find solution for the following set of equations
A = np.array([[1, 2], [3, 4]])
B = np.array([5, 6])
linalg.solve(A, B)

A = np.array([[2, 3, 1], [1, -1, -1], [1, 1, 1]])
B = np.array([1, 2, 1])
linalg.solve(A, B)

""">4) integrate: Integral"""

#solve the integration of sin(x) from 0 to pi (적분)
import numpy as np
from scipy.integrate import quad #Compute a definite integral.
def f(x):
  return np.sin(x)

result, x = quad(f, 0, np.pi) #, x will give calculated error

print("Result of Integration:", result)
print("Error of Integration:", x)

""">5) stats: Statistical distributions and functions"""

#Normal Distribtution (정규분포)
from scipy import stats
from scipy.stats import norm

mu = 0 #center
sigma = 1 #standard deviation
dist = norm(mu, sigma) #normal distribution

random_numbers = dist.rvs(size=100) #.rvs: random variates
x = np.linspace(-4, 4, 100)
pdf = dist.pdf(x) #.pdf: probability density function

plt.plot(x, pdf)
plt.title("Normal Distribution (PDF)")
plt.xlabel('x')
plt.ylabel('Probability Density')

#Uniform Distribution (균일분포)
from scipy.stats import uniform

loc = 0
scale = 10
dist = uniform(loc, scale) #uniform distribution

random_numbers = dist.rvs(size=100) #.rsv
x = np.linspace(-2, 12, 100)
pdf = dist.pdf(x) #.pdf

plt.plot(x, pdf)
plt.title('Uniform Distribution (PDF)')
plt.xlabel('x')
plt.ylabel('Uniform Distribution Density')

"""####5/28: Matplotlib Library

>Matplotlib:
* Plot types: Pairwise, Statistical distribution, Gridded, 3D
"""

'''
01. Plot a surface 3d plot which z is square of x^2 + y^2, with colormap
'''
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
#from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)

fig = plt.figure()
ax = fig.add_subplot(111, projection = '3d')

X, Y = np.meshgrid(x, y) #merge vectors to matrix
Z = np.sin(np.sqrt(X**2 + Y**2))

fig = plt.figure(figsize= (10, 5))

ax.plot_surface(X, Y, Z, cmap= 'jet') #colormap
#fig.colorbar(surf)

'''
02. Plot a graph with two subplots by the same x-axis
'''
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

fig, (ax1, ax2) = plt.subplots(2, 1, sharex= True) #share same axes x

ax1.plot(x, y1)
ax1.set_title('Sine')

ax2.plot(x, y2)
ax2.set_title('Cosine')

plt.xlabel('x')

'''
03. A lot with two y-axes
'''
x = np.arange(0, 10, 0.1) #step
y1 = np.sin(x)
y2 = np.exp(x/10)

fig, ax1 = plt.subplots()
ax2 = ax1.twinx() #same x-axe

ax1.plot(x, y1, 'g-')
ax2.plot(x, y2, 'b-')

ax1.set_xlabel('X Data')

ax1.set_ylabel('Sin', color='g')
ax2.set_ylabel('Exp', color='b')

'''
04. Plot an Animated sin(x)
'''
from matplotlib import rc
import matplotlib.animation as animation
from IPython.display import HTML

fig, ax = plt.subplots()
x = np.linspace(0, 2 * np.pi, 100)
line, = ax.plot(x, np.sin(x))

def update(frame): #animate the sine wave by updating its y-data in each frame
  line.set_ydata(np.sin(x + frame / 10))
  return line,

rc('animation', html='html5') #html options: jshtml, html5
ani = animation.FuncAnimation(fig, update, frames=100, blit= True) #blitting is used to optimize drawing.
ani

'''
05. Plot a polar plot
'''
theta = np.linspace(0, 2 * np.pi, 100)
r = np.abs(np.sin(theta) * np.cos(theta))

plt.subplot(111, polar= True) #Create Polar Plot Space
plt.plot(theta, r)

'''
06 Plot a spider plot
'''
labels= np.array(['A', 'B', 'C', 'D'])
num_vars = len(labels)

def radar_chart(ax, angles, values, title= None, color= 'b'):
  ax.plot(angles, values, color= color)
  ax.fill(angles, values, color= color, alpha= 0.25)
  ax.set_xticks(angles) #Set the xaxis' tick locations
  ax.set_xticklabels(labels, fontsize= 10)
  ax.set_yticklabels([])
  ax.grid(True)

values = np.array([4, 3, 2, 5]) #4D
angles = np.linspace(0, 2 * np.pi, num_vars, endpoint= False).tolist()

fig, ax = plt.subplots(figsize= (6,6), subplot_kw= dict(polar= True))
#Dict with keywords passed to the add_subplot call used to create each subplot.
radar_chart(ax, angles, values, color= 'r')

'''
07. Heatmap with Text annotations
'''
data = np.random.rand(10, 10)
fig, ax = plt.subplots()
cax = ax.matshow(data, cmap= 'coolwarm') #matrix show

for (i, j), val in np.ndenumerate(data): #red correlation shows close to 1
  ax.text(j, i, f'{val:.2f}', ha= 'center', va= 'center') #horizontal align, vertical align

fig.colorbar(cax)

'''
08. Create custom line in plot
'''
x = np.linspace(0, 10, 100)
y = np.sin(x)

plt.plot(x, y, linestyle='--', marker='o', color= 'r')

""">Seaborn: provides several built-in datasets that can used for data visualization and statistical analysis."""

'''
01. Plot a graph with two subplots by the same y-axis
'''
import seaborn as sns

tips = sns.load_dataset('tips')
g = sns.FacetGrid(tips, col='time', height=4, aspect=0.7)
g.map(sns.scatterplot, 'total_bill', 'tip')

'''
02. Violin Plot using seaborn
'''
import seaborn as sns
data = np.random.rand(100, 4)
sns.violinplot(data=data)

'''
03. Violinplot with Colors
'''
tips = sns.load_dataset('tips')
sns.violinplot(x= 'day', y= 'total_bill', hue= 'sex', data= tips, split= True, inner= 'quart', palette= 'muted')
#hue: categorical column name

#inner: box, point, stick, quart
#palette: deep, muted, bright, pastel, dark, colorblind

'''
04. Pair plot with different forms
'''
iris = sns.load_dataset('iris') #provided dataset in seaborn
g = sns.PairGrid(iris) #Subplot grid for plotting pairwise relationships in a dataset.

g.map_diag(sns.histplot)  #diagonal
g.map_upper(sns.kdeplot)     #upper
g.map_lower(sns.scatterplot) #lower

'''
05. Joint plot with hex and kde
'''
#Jointplot: Draw multiple bivariate plots with univariate marginal distributions.
sns.jointplot(x='total_bill', y='tip', data=sns.load_dataset('tips'), kind= 'hex', marginal_kws= dict(bins=50, fill=True))
#kind: scatter, hex, kde, reg, resid, hist
#marginal_kws: bins, fill
 #bins: number of bins (intervals) for the marginal histograms.
 #fill: determines whether the histogram bars should be filled with color.

'''
06. Custom Line Plot with Multiple Lines and Markers
'''
fmri = sns.load_dataset('fmri') #functional MRI
sns.lineplot(data=fmri, x='timepoint', y='signal', hue='region', style='event', markers=True, dashes=True)
#hue: based on the dataset fmri attributes
#style: categorial variable in the fmri dataset

'''
07. Categorial Plot with Multiple Variables
'''
sns.catplot(x='day', y='total_bill', hue='smoker', col='time', data= tips, kind='swarm', height=4, aspect=0.7)
#catplot: figure-level interface for drawing categorical plots.
#swarm: draw a categorical scatterplot with points adjusted to be non-overlapping.

'''
08. Complex boxplot with nested grouping
'''
sns.boxplot(x='day', y='total_bill', hue='time', data=tips, palette='coolwarm')

'''
09. A swarm plot with box plot
'''
sns.boxplot(x='day', y='total_bill', hue='time', data=tips) #shows range
sns.swarmplot(x='day', y='total_bill', hue='time', data=tips, color='.25') #shows realdata

'''
10. Multiple linear regressions in a single plot
'''
sns.lmplot(x='total_bill', y='tip', hue='smoker', data=tips, markers=['o', 'x'], palette='Set1')

""">Plotly: Python graphing library that makes interactive, publication-quality graphs."""

'''
01. interactive 3D Scatter Plot using plotly
'''
import plotly.express as px

df = px.data.iris() #using iris dataset
fig = px.scatter_3d(df, x= 'sepal_length', y= 'sepal_width', z= 'petal_width',
                  color= 'species', size= 'petal_length', symbol= 'species')
fig.show()

'''
02. Interactive Choropleth map using plotly
'''
#Choropleth map: thematic map that is used to represent statistical data using the color mapping symbology technique.
df = px.data.gapminder()
fig = px.choropleth(df, locations= 'iso_alpha', color ='lifeExp', hover_name= 'country',
                    animation_frame= 'year', projection= 'natural earth')
fig.show()

'''
03. Interactive Parallel Coordinates Plot using Plotly
'''
df = px.data.iris()
#평행좌표: Create a Y axis, as same as the input field X, and draw by connecting the values ​​in the same row, with a line.
fig = px.parallel_coordinates(df, color= 'species_id',
                              labels= {'species_id': 'Species',
                                       'sepal_width': 'Sepal Width', 'sepal_length': 'Sepal_Length',
                                       'petal_width': 'Petal Width', 'petal_length': 'Petal_Length'},
                              color_continuous_scale= px.colors.diverging.Tealrose,
                              color_continuous_midpoint= 2)
fig.show()

'''
04. Interactive Treemap using Plotly
'''
df = px.data.tips() #using tips dataset

fig = px.treemap(df, path= ['day', 'time', 'sex'], values= 'total_bill',
                 color= 'tip', hover_data= ['tip'],
                 color_continuous_scale= 'RdBu',
                 color_continuous_midpoint= df['tip'].mean())
                #Diverging color scales have a well-defined midpoint color,
                #and are best-used when that midpoint is mapped to a meaningful data value.
fig.show()

'''
05. Interactive Network Graph using NetworkX and Plotly
'''
import networkx as nx
import plotly.graph_objs as go

G = nx.karate_club_graph() #returns Zachary's Karate Club graph.
pos = nx.spring_layout(G)
edge_trace = go.Scatter(x= [], y= [], line= dict(width=0.5, color='#888'),
                        hoverinfo= 'none', mode= 'lines')

for edge in G.edges():   #create edges
  x0, y0 = pos[edge[0]]
  x1, y1 = pos[edge[1]]
  edge_trace['x'] += (x0, x1, None)
  edge_trace['y'] += (y0, y1, None)

node_trace = go.Scatter( #nodes as a scatter trace
    x= [], y= [], text=[], mode= 'markers', hoverinfo= 'text',
    marker= dict(showscale= True, colorscale= 'YlGnBu', size= 10,
                 colorbar= dict(thickness= 15), line_width= 2))

fig = go.Figure(data= [edge_trace, node_trace]) #create network graph
fig.show()

'''
06. Interactive Linked Scatter Plot using Altair
'''
import altair as alt #Vega-Altair is a declarative visualization library for Python.
from vega_datasets import data

source = data.cars() #dataset
brush = alt.selection_interval()

points = alt.Chart(source).mark_point().encode(
    x= 'Horsepower:Q',
    y= 'Miles_per_Gallon:Q',
    color= alt.condition(brush, 'Origin:N', alt.value('lightgray')) #colors the points by origin
).add_selection(
    brush
)

points

"""###V. Assignment Projects 2

####5/14: NLTK Library Showcase

1) NLTK and Data Installation
"""

import nltk

#downloading book data in nltk
nltk.download("book")
from nltk.book import * #all books

nltk.corpus.gutenberg.fileids() #corpus.gutengerg contains some 25,000 free electronic books from gutenberg project
#will show fileids

#sample book
carroll_words = nltk.corpus.gutenberg.words("carroll-alice.txt")
len(carroll_words) #total number of words

carroll_sents = nltk.corpus.gutenberg.sents("carroll-alice.txt")
len(carroll_sents) #total number of sentences

carroll_raw = nltk.corpus.gutenberg.raw("carroll-alice.txt")
print(carroll_raw[:997]) #print raw text file using character index slicing

"""2) NLTK Tokenizer Module"""

#nltk tokenizer
from nltk.tokenize import sent_tokenize #sentence

print(sent_tokenize(carroll_raw)[2])

print(sent_tokenize(carroll_raw[:997])[1]) #print one sentence in index range

from nltk.tokenize import word_tokenize #word
word_tokenize(carroll_raw[1:50]) #tokenized word in character index range

from nltk.tokenize import RegexpTokenizer #splits a string into substrings using a regular expression.
retokenizer = RegexpTokenizer("[\w]+") #means one or more word characters : another way to word tokenize
retokenizer.tokenize(carroll_raw[1:50]) #same result as above

"""3) NLTK Morpheme related Modules"""

#word stemmer
from nltk.stem import PorterStemmer, LancasterStemmer #A word stemmer based on the stemming algorithms.
stemmerP = PorterStemmer()
stemmerL = LancasterStemmer()

wordlist = ['sing', 'sings', 'sang', 'singing', 'sung', 'fly', 'flies', 'flying', 'flew', 'flown']

print("1) Porter Stemmer:")
print([stemmerP.stem(word) for word in wordlist])
print("2) Lancaster Stemmer:")
print([stemmerL.stem(word) for word in wordlist])

from nltk.stem import WordNetLemmatizer #recovering word original form

lemmatizer = WordNetLemmatizer()

print([lemmatizer.lemmatize(word, pos="v") for word in wordlist]) #parts of speech
print(lemmatizer.lemmatize('better', pos='a'))

"""4) NLTK Part of Speech Tag Module"""

#NLTK uses Penn Treebank Tagset
'''examples:
NNP: Singular proper noun
NN: Noun (singular or collective)

VB: Verb
VBP: Present tense of verb
VBD: Past tense of verb

TO: To preposition
DT: Adjective'''

#to get more info on each tag
nltk.help.upenn_tagset("VB")

from nltk.tag import pos_tag #tags pos in tuple form for each word
sentence = "Carroll refused to permit us to obtain the refuse permit"
tagged_wordlist = pos_tag(word_tokenize(sentence)) #use word_tokenize
tagged_wordlist

noun_list = [tagged_word[0] for tagged_word in tagged_wordlist if tagged_word[1] == "NN"] #checks each word tuple ("word", "NN") prints "word"
noun_list

from nltk.tag import untag #remove tags
untag(tagged_wordlist)

"""5) NLTK Text Module"""

from nltk import Text #module brings together a variety of NLTK functionality for text analysis, and provides simple, interactive interfaces.

text_words = Text(retokenizer.tokenize(carroll_raw)) #using retokenizer and carroll_raw file again

#show 25 most common tokens
text_words.plot(25) #can check that the is no.1 most used word

text_words.dispersion_plot(["Alice"]) #shows the location when the word is used in the text

text_words.concordance("Alice") #can check the word's location with context

text_words.similar("Alice") #distributional similarity: find other words which appear in the same contexts as the specified word; list most similar words first.

"""6) NLTK Frequency Distribution Module"""

from nltk import FreqDist #can be used to calculate frequency distribution of the words

excepts = ["Mr.", "Mrs.", "Miss", "Mr", "Mrs", "Dear"] #don't include these words
carroll_tagged_tokens = pos_tag(retokenizer.tokenize(carroll_raw))

names_list = [tagged[0] for tagged in carroll_tagged_tokens if tagged[1] == "NNP" and tagged[0] not in excepts]

print(names_list)

fd_names_list = FreqDist(names_list)

print(fd_names_list.N()) #total number of names
print(fd_names_list["Alice"]) #total number of name "Alice"

print(fd_names_list.freq("Alice")) #Frequency of appearance of name "Alice" among total names

fd_names_list.most_common(5) #most common names among names list, with its frequency

"""7) NLTK Word Cloud Module"""

from wordcloud import WordCloud
#generating word cloud format
word_cld = WordCloud(width=1000, height=600, background_color="black", random_state=0) #random_state is related to location of words

import matplotlib.pyplot as plt
plt.imshow(word_cld.generate_from_frequencies(fd_names_list)) #create image, using the freqdist data
plt.axis("off") #turn off axis
plt.show()

"""###VI. Final Exam Questions *Jupyter*

####6/04: Classes, Pandas, Matplotlib
"""

import pandas as pd

file_path = 'Desktop/student_dataset.csv' #using Jupyter

df1 = pd.read_csv(file_path)

pd.DataFrame(df1)

df1.columns

#01. write a function that calculates the average grades for each subject

sum = 0
cnt = 0
for i in df1['math.grade']:
    sum += i
    cnt = cnt + 1
print(sum/cnt)

sum = 0
cnt = 0
for i in df1['english.grade']:
    sum += i
    cnt = cnt + 1
print(sum/cnt)

val = df1['english.grade'].mean()
print(val)

sum = 0
cnt = 0
for i in df1['sciences.grade']:
    sum += i
    cnt = cnt + 1
print(sum/cnt)

sum = 0
cnt = 0
for i in df1['language.grade']:
    sum += i
    cnt = cnt + 1
print(sum/cnt)

#02. Write a class that encapsulates the functionality to add a new column
#to the DataFrame with the overall average grade for each student

keys = list(df1.columns)

class StuAvg:
    def __init__(self, df1):
        self.df1 = df1
    def create_avg(self, df1):
        idx = df1.columns.get_loc('english.grade')
        new_col = 'average'
        cols = df1.columns.tolist()
        cols.insert(idx - 1, new_col)
        print(cols)
        df1 = df1.reindex(columns = cols)
        return df1
    def add_avg(self, df1):
        df1['average'] = df1.apply(lambda row: (row['english.grade'] + row['math.grade'] + row['sciences.grade'] + row['language.grade']) / 4 if pd.isna(row['average']) else row['average'], axis=1)
        return df1
    def printer(self, df1):
        print(df1)

test = StuAvg(df1)

test.printer(df1)

df2 = test.create_avg(df1)
test.printer(df2)

df2 = test.add_avg(df2)
test.printer(df2)

#03. Write a code to find correlation between the different grades
#and then draw a heatmap to show the correlation
#(for correlation you may use: correlations = grades_df.corr(method='pearson')

pip install matplotlib

import matplotlib.pyplot as plt
import numpy as np

grades_df1 = df1[['english.grade', 'math.grade', 'sciences.grade', 'language.grade']]
corr_data = grades_df1.corr(method='pearson')

fig, ax = plt.subplots()

gr = ax.matshow(corr_data, cmap= 'coolwarm')

for (i, j), val in np.ndenumerate(corr_data):
    ax.text(i, j, f'{val:.2f}', ha='center', va='center')

fig.colorbar(gr)

#04. Show count, mean, 25%, 50%, 75%, max
#for math.grade, english.grade, sciences.grade, language.grade

df1[['english.grade', 'math.grade', 'sciences.grade', 'language.grade']].describe()

"""####6/11: Pandas, Matplotlib"""

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('Desktop/student_dataset.csv')
pd.DataFrame(df)

drop_df = df.drop(columns= ['latitude', 'longitude', 'ethnic.group', 'portfolio.rating', 'coverletter.rating', 'refletter.rating'])
drop_df

df.rename(columns = {'english.grade' : 'English', 'math.grade' : 'Math', 'sciences.grade' : 'Sciences', 'language.grade' : 'Language'}, inplace=True)
df.columns

print(df['english.grade'].mean())
print(df['sciences.grade'].mean())
print(df['language.grade'].mean())
print(df['math.grade'].mean())

cor_data = df[['English', 'Math', 'Sciences', 'Language']].corr()
print(cor_data)

fig, ax = plt.subplots()
ax.matshow(cor_data, cmap='coolwarm')

group_df = df.groupby(['gender', 'age'])[['English', 'Math', 'Sciences', 'Language']].mean()
group_df

mean_df = df.groupby('nationality')[['English', 'Math', 'Sciences', 'Language']].mean().head(5)
mean_df

new_col = 'location'
col_lst = df.columns.tolist()
col_idx = df.columns.get_loc('name')
col_lst.insert(col_idx + 1, new_col)
df = df.reindex(columns= col_lst)
pd.DataFrame(df)

df['location'] = df.apply(lambda x: x['nationality'] + ' ' + x['city'], axis=1)
pd.DataFrame(df)

count_df = df['nationality'].value_counts()
count_df

df['English'] = df.apply(lambda x: 0 if x['English'] < 0 else x['English'], axis = 1)
df['Language'] = df.apply(lambda x: 0 if x['Language'] < 0 else x['Language'], axis = 1)
df['Math'] = df.apply(lambda x: 0 if x['Math'] < 0 else x['Math'], axis = 1)
df['Sciences'] = df.apply(lambda x: 0 if x['Sciences'] < 0 else x['Sciences'], axis = 1)
pd.DataFrame(df)

sort_df = df.sort_values(by= ['age', 'gender'], ascending= [True, True])
sort_df

group_df2 = df.groupby(['nationality', 'city'])[['age', 'English', 'Math', 'Sciences', 'Language']].mean()
group_df2

pv_df = pd.pivot_table(df, values= ['English', 'Math', 'Sciences', 'Language'], index= ['age'], columns= ['gender'], aggfunc= 'mean')
pv_df